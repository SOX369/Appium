# 软件测试笔记





## 测试类型

**一、按测试层次（测试阶段）分类**

| 测试类型 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 单元测试 | 测试代码中最小的可测试单元（如函数、方法、类），由开发人员编写，验证代码逻辑正确性。 |
| 集成测试 | 将多个经过单元测试的模块组合在一起，测试它们之间的接口和交互是否正确。 |
| 系统测试 | 将整个软件系统作为一个整体进行测试，模拟真实的用户环境，验证其是否满足所有功能和非功能性需求。 |
| 验收测试 | 通常由最终用户或产品经理来执行，以确认软件是否满足用户的实际需求和期望，是产品发布前的最后一关。 |

**二、按测试目的（测试性质）分类**

1. 功能性测试（关注“做的是对的”）

| 测试类型 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 功能测试 | 根据需求规格说明书，验证软件功能是否符合业务要求（黑盒测试）。 |
| 回归测试 | 在软件修改（新增功能、修复Bug、代码重构等）后，重新执行已有测试用例，以验证**修改没有引入新的缺陷**，或**原有功能没有受到影响**。 |
| 冒烟测试 | 也称为烟雾测试或建构验证测试，是一种浅层广度的测试，目的是**快速验证系统核心功能是否正常**（即“系统是否冒烟”） |
| 接口测试 | 针对系统内部模块间或外部系统间的接口（API、Web Service等）进行测试，验证数据交互的正确性。 |

2. 非功能性测试（关注“做得好不好”）

| 测试类型   | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 性能测试   | 验证系统在高负载下的响应速度、吞吐量、稳定性等。包括负载测试、压力测试、稳定性测试等。 |
| 安全测试   | 发现系统中的安全漏洞（如SQL注入、XSS、权限绕过等）。         |
| 兼容性测试 | 验证软件在不同环境（如浏览器、操作系统、设备、分辨率）下的表现是否一致。 |

**三、按测试方法分类**

| 测试类型   | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 线性测试   | 最基础的自动化方式，测试脚本严格**按照从头到尾的线性顺序一步一步执行**。通常是通过录制回放或手动逐行编写脚本实现。 |
| 边界测试   | 一种黑盒测试技术，重点测试输入值的边界情况（如最小值、最大值、刚好超出边界等），缺陷往往出现在边界。 |
| 探索性测试 | 不依赖预先写好的详细脚本，测试人员凭借经验边设计边执行，擅长发现隐藏缺陷，依赖人工。 |
| 端到端测试 | 模拟真实用户从头到尾完整操作整个系统（如从登录到下单支付的全流程）。推荐自动化（Selenium、Appium、Cypress） |













## 测试技术栈的关系图

你可以把整个测试体系想象成**盖房子**：

1. **功能测试 (基石)**：房子的设计图和砖块。如果不知道房子该长什么样（业务逻辑），用什么工具都白搭。
2. **编程语言 & 数据库 (水泥/工具)**：连接一切的基础能力。不懂代码，自动化和性能测试就寸步难行。
3. **接口测试 (内部管道)**：房子的水电管线。虽然看不见，但决定了房子能不能住（后端逻辑）。**这是目前性价比最高的技能。**
4. **UI 自动化测试 (智能家居)**：模拟人自动开关灯。用于回归测试，减少重复劳动。
5. **性能测试 (抗震检测)**：测试房子能容纳多少人同时聚会。
6. **CI/CD (自动化流水线)**：把上面所有步骤串联起来，实现“一键盖房”。

###  阶段一：打好地基 —— 功能测试与基础技能

**目标**：能够独立承担业务测试任务，准确发现并定位 Bug。

- **核心知识**：

  - **测试理论**：软件生命周期、测试用例设计方法（等价类、边界值、场景法）、Bug 生命周期。
  - **网络基础**：HTTP/HTTPS 协议，GET/POST 区别，Cookie/Session。**（必学！）**
  - **数据库**：SQL 增删改查（尤其是多表查询 `JOIN`）。
  - **Linux**：常用命令（`ls`, `grep`, `tail -f` 查看日志, `chmod`）。

- **必备工具**：

  - **抓包工具**：**Fiddler** 或 **Charles**。*(非常重要！用于区分 Bug 是前端传参错了，还是后端处理错了。)*
  - **浏览器开发者工具**：Chrome F12（Network 面板）。
  - **用例/Bug 管理**：Excel / XMind（思维导图梳理测试点）/ Jira / 禅道。

- 学习建议：

  入职第一周，重点不是学代码，而是搞懂公司的业务流程和数据库表结构。

### 阶段二：技术进阶 —— 接口测试 (API Testing)

**目标**：跳过前端界面，直接验证后端逻辑，这是自动化测试的**核心**。

- **核心知识**：

  - RESTful 风格、JSON 数据格式。
  - 接口文档阅读（Swagger/YApi）。
  - 断言（验证状态码、返回值是否正确）。

- **必备工具**：

  - **Postman**：手工接口测试神器。学习如何发请求、设置环境变量、写简单的断言脚本。
  - **JMeter**：虽然是性能工具，但常用于接口自动化。

- 模块关系：

  接口测试比 UI 测试更稳定、执行更快。它是连接手工测试和代码自动化的桥梁。

###  阶段三：自动化入门 —— 编程语言 & 测试框架

**目标**：从“点工”向“测试开发”转型，用代码代替人工。

- **核心知识**：
  - **编程语言**：推荐 **Python**（上手快，脚本强）或 **Java**（大厂后端通用）。选定一门深入。
  - **单元/接口自动化框架**：
    - Python: **Pytest** + **Requests** (最流行搭配)。
    - Java: **JUnit/TestNG** + **RestAssured**。
- **学习路径**：
  1. 学 Python 基础语法（列表、字典、函数、类）。
  2. 用 Requests 库发请求代替 Postman。
  3. 用 Pytest 组织管理这些脚本，生成测试报告（Allure）。

###  阶段四：看得见的自动化 —— Web & App UI 自动化

**目标**：模拟用户点击，主要用于**回归测试**（保证旧功能没坏）。

- **必备工具**：

  - **Web 端**：**Selenium** (经典必学) 或 **Playwright** (新一代，推荐)。
  - **移动端 (App)**：**Appium** (目前行业标准)。

- **核心概念**：

  - **元素定位**：XPath, CSS Selector（如果在阶段一学好了 F12，这里很轻松）。
  - **PO 模式 (Page Object)**：如何写出易维护的代码结构。

- 模块关系：

  UI 自动化维护成本高，通常在接口自动化完善之后再做，或者只做核心流程（登录->下单->支付）。

###  阶段五：挑战高薪 —— 性能测试

**目标**：保证系统在高并发下的稳定性。

- **核心知识**：

  - 指标理解：TPS (每秒事务数), QPS, 响应时间, 吞吐量, CPU/内存利用率。
  - 场景设计：单接口压测、混合场景压测。

- **必备工具**：

  - **JMeter**：开源、轻量、大厂最常用。
  - **LoadRunner**：老牌商业软件，银行/国企用得多。
  - **Locust**：基于 Python 代码的压测工具。

- 学习建议：

  不要只学工具怎么操作，重点是学如何分析瓶颈（是数据库慢？代码死锁？还是带宽不够？）。

### 阶段六：终极融合 —— CI/CD (DevOps)

**目标**：将测试脚本接入公司的流水线，实现无人值守测试。

- **必备工具**：

  - **Git**：代码版本管理（pull, push, merge）。
  - **Jenkins**：持续集成服务器。

- 实际场景：

  开发提交代码到 Git -> Jenkins 自动检测 -> 自动拉取代码 -> 自动运行 Pytest/Selenium 脚本 -> 自动发送邮件/钉钉报告给团队。

- 模块关系：

  CI/CD 是容器，装载了你前面写的所有自动化脚本。

### 总结：推荐的学习顺序表

| **阶段** | **优先级** | **关键词**    | **必学工具/技术**                       | **产出物**                        |
| -------- | ---------- | ------------- | --------------------------------------- | --------------------------------- |
| **1**    | ⭐⭐⭐⭐⭐      | **功能/业务** | 抓包(Fiddler/Charles), SQL, Linux, 禅道 | 高质量的测试用例, 准确的 Bug 报告 |
| **2**    | ⭐⭐⭐⭐       | **编程基础**  | Python (或 Java)                        | 能看懂开发代码，能写简单的脚本    |
| **3**    | ⭐⭐⭐⭐⭐      | **接口测试**  | Postman, **Pytest+Requests**            | 接口自动化测试脚本 (性价比最高)   |
| **4**    | ⭐⭐⭐        | **UI 自动化** | Selenium, Appium                        | 核心业务流程的回归脚本            |
| **5**    | ⭐⭐⭐        | **CI/CD**     | Git, Jenkins                            | 每日定时运行的任务配置            |
| **6**    | ⭐⭐         | **性能测试**  | JMeter                                  | 压测报告与性能分析                |

### 给新人的建议

1. **入职第 1 个月**：
   - **疯狂熟悉业务**。不懂业务的测试是没有前途的。
   - **精通抓包（Fiddler/Charles）和 F12**。这能让你在提 Bug 时更有底气，直接告诉开发是前端传参错了还是后端报错了。
   - **熟练 SQL**。能自己去数据库查数据，而不是每次都麻烦开发。
2. **入职 2-3 个月后**：
   - 开始学习 **Python + Requests + Pytest**。尝试把手头的重复性数据构造工作，或者核心接口写成自动化脚本。
3. **长期规划**：
   - 关注公司的技术栈，如果公司全是 Java，那你后续可能要考虑转 Java。
   - 如果有机会，主动申请参与公司现有的自动化项目，哪怕只是维护代码。















## 一、Appium自动化测试框架

### **核心原理**：

​	Appium框架是**基于客户端/服务器（C/S）的一种架构**。它的核心是一个用Node.js编写的**Appium Server**（服务器），这个服务器扮演一个“中间代理”的角色，**接收客户端的测试指令，并将其翻译成目标平台的原生指令**。它扩展了Selenium的**WebDriver协议**，使其能够支持移动端。当我们在客户端编写执行一个测试脚本时，它会向Appium Server发送一个标准的HTTP请求，Appium Server收到这个命令后，会根据我们启动会话时提供的平台信息，将这个标准命令“翻译”成对应平台的原生自动化框架能听懂的指令：对于Android，它会使用**UiAutomator2**框架；对于iOS，它会使用**XCUITest**框架。然后，它通过这些原生框架在设备上执行操作，并将执行结果返回给我们的测试脚本。



### **测试步骤**：

启动Appium Server服务器后，它会监听一个端口（默认为4723）；

（1）**初始化**：在测试代码中，首先配置连接设备的参数信息，如`platformName`设置要连接的是哪个平台（Android还是iOS）、`deviceName`设备名称id、`appPackage`要启动的应用包名、`appActivity`要启动的应用UI界面。

（2）**定位元素**：Appium Server根据这些信息在指定设备上启动应用并建立会话，一旦会话成功创建，我们的`driver`对象就获得了控制权，接下来的使用`driver`对象来**定位元素**；Appium支持`ID`、`XPATH`、`Accessibility ID`等标准定位器；我一般使用`Inspector`来查找并定位，手机App中UI界面的元素；

（3）**执行操作并断言验证**：找到元素后，就可以执行**交互操作**，包括`Click()`（点击）和`Send_Keys()`（输入文本）等标准操作，此外Appium扩展了WebDriver协议，支持了移动端特有的**手势操作**，如`Swipe`（滑动）、`Tap`（按坐标轻点）等；在关键步骤执行后，我们会获取最终界面元素的文本或属性来进行**断言**，验证UI状态是否符合预期。

（4）**关闭Session**：当测试用例执行完毕，我们调用`driver->Quit()`方法，通知Appium Server终止会话，清理设备上的代理并关闭应用程序，从而完成一个完整的自动化测试闭环。



**常用adb命令：**

```
adb shell getprop ro.build.version.release					获取手机版本号
```

```
adb shell dumpsys window | findstr mCurrentFocus			获取手机当前启动的app和界面
```



**appium客户端测试指令：**

```
'presence_of_element_located'(元素存在即可)
```

元素可能是**不可见的**（比如透明度为0，或者长宽为0，或者被遮挡），也可能还没渲染出来，但只要代码里有这一行，它就满足条件。

```
`EC.visibility_of_element_located` (等待“可见”)
```

检查元素在屏幕上是**可见的**， 当不需要点击，而是要 `.send_keys()` 或 `.get_text()` 这个元素，就应该使用 `EC.visibility_of_element_located`。

```
`EC.element_to_be_clickable` (等待“可点击”)
```

检查元素是 **`enabled` (可用)** 的，当需要 `.click()` 这个元素，就应该使用 `EC.element_to_be_clickable`。



### 自动化测试项目完整流程总结：

**阶段一：测试环境搭建** 

这是所有工作的基础，首先要搭建一套完整的 App 自动化测试环境，主要包括：

- **基础环境：** 安装 **Java SDK** (Android SDK 依赖) 和 **Android SDK** (提供 `adb` 等调试工具)。
- **核心服务：** 安装 **Appium Server** (v1.x GUI 或 v2.x 命令行)，作为自动化指令的中转站。
- **测试端：** 准备 Python 环境，并安装核心的第三方库，即 **`Appium-Python-Client`**。
- **执行设备：** 准备测试用的**真机**或**手机模拟器**，并确保 `adb` 可以成功连接。

**阶段二：线性脚本编写** 

在环境搭好后，进入初期的脚本编写阶段，也称为“线性脚本”或“脚本化”阶段。

- **1. 业务梳理：** 首先，梳理 App 的核心业务模块，例如：
  - 登录/注册
  - 浏览文章
  - 发布文章
  - 点赞、评论、收藏
- **2. 编写脚本：** 针对每个核心业务，我会创建独立的 `.py` 脚本文件（如 `toutiao_login.py`）。
- **3. 冒烟测试：** 我会编写包含正反例的自动化用例，执行第一轮“冒烟测试”，确保自动化流程可以跑通。
- **4. 添加断言：** 在关键步骤后加入断言（Assert），以保证自动化用例的准确性。

**阶段三：架构设计 - 引入 POM 模式**

线性脚本的维护性很差。为了让框架更健壮、可维护，我会引入**页面对象模型 (Page Object Model, POM)** 来进行封装。

- **1. 页面封装 (Encapsulation)：**
  - **页面类：** 我会为 App 的**每一个界面**（或一个独立的流程）创建一个专属的 Python 类（例如 `LoginPage.py`）。
  - **元素属性：** 将该界面上所有需要操作的元素（Element Locators），封装为这个类的**类属性**。
  - **操作方法：** 将对这些元素的操作（如点击、输入），封装成这个类的**实例方法**（例如 `def login(self, user, pass):`）。
- **2. 测试类使用 (Usage)：**
  - 在**测试用例 (Test Case)** 脚本中，我不会再写 `driver.find_element`。
  - 我会**创建页面类的对象**，然后**调用**这个对象的方法来执行业务步骤。
  - 最后，在用例脚本中获取方法的返回值，执行**断言**。
- **好处：** 这样能实现**UI 元素**、**操作逻辑**和**测试用例**的彻底分离。当界面UI变化时，我只需要去修改对应的页面类，而不需要改动测试用例。

**阶段四：框架集成与数据驱动**

在 POM 架构之上，我会引入专业的测试框架（如 **Pytest**）来管理和执行用例。

- **1. 用例管理：** 使用 Pytest 来组织和执行所有的测试用例。
- **2. 数据驱动 (Data-Driven)：**
  - 为了分离“测试数据”和“测试逻辑”，我会使用参数化来进行数据驱动测试。
  - 我会使用 Pytest 的 `@pytest.mark.parametrize` 装饰器。
  - 对于大量的数据（尤其是正反例数据），我会将它们存储在外部文件中，例如 **YAML**、**JSON**、CSV 或 Excel，然后在用例执行时动态读取这些数据。

**阶段五：报告、日志与持续集成 (CI/CD)**

最后，为了让自动化流程闭环，我会完善配套的工程化设施：

- **1. 日志记录 (Logging)：** 在框架中加入详细的日志记录功能，方便在测试失败时快速定位问题。
- **2. 测试报告 (Reporting)：** 集成如 Allure 这样的测试报告库，生成可视化的缺陷报告。
- **3. 持续集成 (CI)：** 将这套自动化脚本对接到公司的 CI/CD 流程中（如 Jenkins），实现自动触发、无人值守的测试。



**🚀Appium 和 Pytest 的关系**

Appium 和 Pytest 都是“自动化测试框架”，但它们属于完全不同的“层级”。

在面试中，如果面试官问您“你的自动化框架是什么？”，最专业的回答是：“**我搭建了一套基于 Pytest + Appium + POM 模式的自动化测试框架。**”

**Appium** 是我的**底层驱动库**，用它来封装页面操作，解决具体的 UI 交互问题，比如滑动、点击和元素定位。

而 **Pytest** 是我的**测试运行框架**，使用 Pytest 来**组织和管理测试用例**。利用它的 `setup/teardown` 机制来管理驱动的生命周期（确保测试前启动、测试后关闭），利用它的 `assert` 进行断言验证，并结合插件生成可视化的测试报告。

- **Appium** 是 **“执行层” **。
  - 它像是一个**“司机”**。
  - 它只负责干活：控制手机、点击按钮、输入文字、滑动屏幕。
  - 它**不知道**什么是“测试用例”，也不知道什么是“通过”或“失败”。它只管执行命令。
- **Pytest** 是 **“管理层” **。
  - 它像是一个**“考官”**。
  - 它负责指挥：决定先测什么、后测什么（用例调度）。
  - 它负责判断：实际结果和预期结果是否一致（断言 `assert`）。
  - 它负责记录：生成测试报告，告诉您哪些通过了，哪些失败了。

**核心区别对比**

如果不使用 Pytest，仅使用 Appium（像您之前的线性脚本），您的代码是“过程式”的；引入 Pytest 后，您的代码变成了“工程化”的。

| **特性**      | **Appium (驱动者)**             | **Pytest (管理者)**                                 |
| ------------- | ------------------------------- | --------------------------------------------------- |
| **核心作用**  | **操作设备** (点击、滑动、输入) | **管理用例** (发现、执行、断言、报告)               |
| **核心代码**  | `driver.find_element(...)`      | `def test_login(): ... assert ...`                  |
| **如果出错**  | 抛出异常，脚本直接崩溃停止      | 捕获异常，标记该用例为 Fail，**继续执行下一个用例** |
| **测试报告**  | 无 (只能靠 `print` 输出)        | 有 (可生成详细的 HTML 报告，如 Allure)              |
| **前置/后置** | 需手动写代码处理 (很麻烦)       | 自动化处理 (`setup_class`, `teardown_class`)        |



### **Appium 核心参数速查表**

| **分类**     | **参数名 (Capability)**       | **必填** | **核心作用 (一句话总结)**                                    | **推荐/常用值**                   |
| ------------ | ----------------------------- | -------- | ------------------------------------------------------------ | --------------------------------- |
| **基础连接** | **`platformName`**            | ✅        | **指定平台**。告诉 Appium 测安卓还是 iOS。                   | `"Android"`                       |
|              | **`deviceName`**              | ✅        | **设备名称**。连接多台设备时用于区分。                       | `"127.0.0.1:4723"` 或型号名       |
| **App信息**  | **`appPackage`**              | ✅        | **App包名** (Android)。指定要测哪个 App。                    | 如 `"com.saucelabs.mydemoapp.rn"` |
|              | **`appActivity`**             | ✅        | **启动页面** (Android)。指定 App 打开展示的第一个页面。      | 如 `".MainActivity"`              |
| **调试保活** | **`noReset`**                 | ❌        | **不重置数据**。设为 `true` 则不清空缓存、不卸载 App。       | `true` (调试推荐)                 |
|              | **`newCommandTimeout`**       | ❌        | **命令超时时间**。脚本暂停多久没反应就自动断开。             | `3600` (1小时)                    |
|              | **`dontStopAppOnReset`**      | ❌        | **不杀进程**。若 App 已在运行，脚本直接接入测试，不重启。    | `true` (调试深层页面用)           |
| **输入优化** | **`connectHardwareKeyboard`** | ❌        | **隐藏软键盘**。模拟物理键盘，防止软键盘弹起遮挡按钮。       | `true` (推荐常开)                 |
|              | **`unicodeKeyboard`**         | ❌        | **Appium 键盘**。支持输入中文/特殊字符，输入速度快。         | `true`                            |
| **性能提速** | **`waitForIdleTimeout`**      | ❌        | **极速模式**。强制 Appium 不傻等页面静止，立即执行操作。     | `0` (毫秒)                        |
| **Webview**  | **`ensureWebviewsHavePages`** | ❌        | **H5 防坑**。确保切换到 Webview 模式时，网页已有内容。       | `true` (混合应用用)               |
| (混合应用)   | **`nativeWebScreenshot`**     | ❌        | **截图修复**。在 Webview 下强制使用原生截图，防止黑屏/错位。 | `true` (截图报错时用)             |



###  四种主流格式的详细对比

| **特性**     | **YAML (.yaml/.yml)**               | **JSON (.json)**           | **CSV (.csv)**            | **Excel (.xlsx)**           |
| ------------ | ----------------------------------- | -------------------------- | ------------------------- | --------------------------- |
| **全称**     | YAML Ain't Markup Language          | JavaScript Object Notation | Comma-Separated Values    | Microsoft Excel             |
| **可读性**   | ⭐⭐⭐⭐⭐ (极高)                        | ⭐⭐⭐ (中等)                 | ⭐⭐⭐ (一般)                | ⭐⭐⭐⭐ (非程序员友好)         |
| **支持注释** | ✅ **支持** (这是巨大的优势)         | ❌ 不支持                   | ❌ 不支持                  | ✅ 支持 (批注)               |
| **数据结构** | 支持复杂的**层级嵌套** (字典、列表) | 支持复杂的**层级嵌套**     | 仅支持**二维表格** (扁平) | 支持多Sheet，但本质是二维表 |
| **解析速度** | 快                                  | 极快                       | 极快                      | 慢 (需要第三方库)           |
| **主要用途** | **配置文件**、测试用例数据          | API接口响应、数据传输      | 大批量简单数据 (如账号库) | 业务人员维护的测试数据      |













## 二、Pytest 测试管理框架



### 为什么选择 Pytest？

- **多端支持**：能够完成 Web、接口（API）以及 App 的自动化测试。
- **报告能力**：能够生成可视化的 Allure 测试报告。



### Pytest 框架基础规范

- **安装方式**：使用命令 `pip install pytest`。
- **命名规范（强制要求）**：
  - **测试模块（文件名）**：必须以 `test_` 开头，例如 `test_login.py`。
  - **测试类名**：必须以 `Test` 开头，例如 `class TestLogin`。
  - **测试用例（方法名）**：必须以 `test_` 开头，例如 `def test_login_success(self)`。
- **构造函数限制**：
  - 在 Pytest 的测试类中，**不能使用 `__init__` 构造函数**。
  - **替代方案**：如果需要进行初始化（前置）或后置处理，应使用框架提供的 `setup` 和 `teardown` 机制（或 Fixture）。



### 核心配置文件

- **`pytest.ini`**
  - **角色**：全局核心配置文件。
  - **核心作用**：用于改变 Pytest 的默认运行行为，确立项目级的通用规则。
  - **应用场景**：配置默认命令行参数（如 `-vs`）、注册自定义标记（Markers）、指定测试用例的根目录或搜索路径。
- **`conftest.py`**
  - **角色**：本地插件与共享配置中心。
  - **核心作用**：存放 Fixture 和 Hook 函数，实现跨文件的资源共享，且**无需显式 import** 即可在当前目录及其子目录生效。
  - **应用场景**：定义通用的 Driver 启动/关闭逻辑、配置失败自动截图钩子、特定目录的环境初始化（导入第三方插件，或者设置通用的环境变量，比如修改 `sys.path`）。



### 核心技术组件

- **Fixture (装饰器)**
  - **角色**：测试环境的前后置管理器。
  - **核心作用**：利用依赖注入机制管理测试依赖。支持**Scope（作用域）**控制（如 `function`, `class`, `module` 级别）以及 **Autouse（自动执行）**。
  - **应用场景**：
    - 资源初始化（如：打开浏览器/APP、连接数据库）。
    - 环境清理（如：关闭驱动、清空测试数据）。
    - 依赖注入（将处理好的对象直接传给测试用例）。
- **Parametrize (参数化)**
  - **角色**：数据驱动测试工具 (`@pytest.mark.parametrize`)。
  - **核心作用**：实现“函数数据参数化”，即将多组测试数据映射到同一个测试逻辑中，自动生成多个独立的测试用例。
  - **应用场景**：需要验证多种输入组合的场景（例如：测试登录功能的成功、密码错误、账号锁定等多种状态），以减少重复代码并提升测试覆盖率。



### 管理框架（Pytest）与执行驱动（Appium）对比

​	Pytest 与 Selenium、Appium 及接口自动化工具（如 Requests）本质上是**“管理框架”与“执行驱动”**的区别。Pytest 是一个通用的**测试运行框架**，它本身并不具备操作浏览器或手机的能力，其核心职责是**组织和调度**，负责发现测试用例、执行断言（判断成败）、管理测试前后的准备与清理工作（Fixture）以及生成测试报告。它可以被看作是自动化测试项目的“指挥官”或“骨架”。

​	相比之下，Selenium、Appium 和接口库则是具体的**操作执行者**，它们各自专注于不同的技术领域。Selenium 专用于 **Web UI 自动化**，负责驱动浏览器模拟用户在网页上的点击和输入；Appium 则是 Selenium 协议在 **移动端** 的延伸，专注于 iOS 和 Android **App 的 UI 自动化**；而接口自动化（通常使用 Requests 等库）则完全脱离 UI，直接在 **网络协议层** 发送 HTTP 请求来验证后端数据逻辑。在实际工作场景中，通常是**以 Pytest 为底座**，根据测试对象的不同，分别调用 Selenium（测网页）、Appium（测手机）或 Requests（测接口）来编写具体的业务代码，最终由 Pytest 统一运行并产出报告。

| **维度**     | **Pytest**                                                   | **Selenium / Appium / Requests**                             |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **角色定位** | **管理框架**（指挥官、骨架、底座）                           | **执行驱动**（操作执行者）                                   |
| **核心能力** | **组织与调度**：发现用例、执行断言、管理 Fixture、生成报告。 | **具体操作**：模拟用户行为（点击、输入）或发送网络请求。     |
| **局限性**   | **不具备**操作浏览器、手机或发送 HTTP 请求的原生能力。       | 无法独立管理测试流程（如生成报告、批量执行），通常需要框架配合。 |

| **工具名称** | **技术领域**      | **核心职责**                 | **特点描述**                                                |
| ------------ | ----------------- | ---------------------------- | ----------------------------------------------------------- |
| **Selenium** | **Web UI 自动化** | 驱动**浏览器**               | 模拟用户在**网页**上的点击、输入等交互操作。                |
| **Appium**   | **App UI 自动化** | 驱动**手机端** (iOS/Android) | Selenium 协议在移动端的延伸，专注于**移动应用**的 UI 操作。 |
| **Requests** | **接口自动化**    | **网络协议层** (HTTP)        | **完全脱离 UI**，直接发送请求验证**后端数据逻辑**。         |















## 三、Allure



```
pytest -vs Appium/MyDemoApp/testcases/test_shopping.py --alluredir=Appium/MyDemoApp/report --clean-alluredir
```

```
allure serve Appium/MyDemoApp/report
```



### Allure 指令总结

| 指令类型           | 命令                 | 参数说明                                 | 示例                                             | 用途                               |
| ------------------ | -------------------- | ---------------------------------------- | ------------------------------------------------ | ---------------------------------- |
| **生成测试数据**   | `pytest --alluredir` | `--alluredir=路径`                       | `pytest test.py -s -q --alluredir=./result/`     | 执行测试并收集Allure结果数据       |
| **一键查看报告**   | `allure serve`       | `结果目录路径`                           | `allure serve ./result/`                         | 自动生成报告并启动服务器打开浏览器 |
| **生成静态报告**   | `allure generate`    | `-o 输出目录` `--clean 清理旧报告`       | `allure generate ./result/ -o ./report/ --clean` | 从测试数据生成HTML报告文件         |
| **打开已生成报告** | `allure open`        | `-h 主机地址` `-p 端口号` `报告目录路径` | `allure open -h 127.0.0.1 -p 8883 ./report/`     | 启动服务器打开已生成的报告         |

`--alluredir`: 指定测试结果存储路径

`-o`: 指定报告输出目录

`--clean`: 覆盖清理旧报告(重要)

`-h`: 指定服务器主机地址

`-p`: 指定服务器端口号





### Allure 报告常用装饰器/方法速查表

| **分类**                     | **装饰器/方法**             | **核心功能**                                                 | **参数说明**                                                 |                         **使用建议**                         |
| :--------------------------- | :-------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------: |
| **1. 层级管理** (左侧导航)   | **`@allure.epic()`**        | **史诗级特性** (最高层级) 通常对应庞大的业务域或大版本。     | `title` (str): 特性名称。                                    |  很少用在单兵作战，通常用于大型项目。标注在 **Class** 上。   |
|                              | **`@allure.feature()`**     | **功能模块** (一级分类) 对应具体的业务模块，如"登录模块"。   | `title` (str): 模块名称。                                    | **必选**。通常标注在 **Test Class** 上，表示该类下的用例都属于此模块。 |
|                              | **`@allure.story()`**       | **用户故事** (二级分类) 对应具体的功能点，如"密码错误登录"。 | `title` (str): 故事名称。                                    | **必选**。通常标注在 **Test Method** 上，区分同一个模块下的不同场景。 |
| **2. 用例描述** (右侧详情)   | **`@allure.title()`**       | **用例标题** 替换默认的函数名，显示中文标题。                | `title` (str): 标题内容。                                    | **静态**：直接装饰在函数上。 **动态**：代码中使用 `allure.dynamic.title()`，适合参数化。 |
|                              | **`@allure.description()`** | **用例描述** 详细展示测试的前提、目的或逻辑。                | `description` (str): 详细文本。                              |  装饰在测试函数上。也可以直接使用函数的 `"""文档注释"""`。   |
|                              | **`@allure.severity()`**    | **严重等级** 标记用例的重要性，支持过滤。                    | `severity_level`:  Blocker, Critical, Normal, Minor, Trivial | 装饰在测试函数上。 常用：`allure.severity_level.CRITICAL`。  |
| **3. 执行步骤** (可视化核心) | **`@allure.step()`**        | **步骤标记 (装饰器模式)** 将函数调用显示为报告中的一个步骤。 | `title` (str): 步骤名称。 支持 `{0}` 占位符。                | **用于 Page Object 层**。 例如：`@allure.step("输入：{username}")`。 |
|                              | **`with allure.step():`**   | **步骤标记 (上下文模式)** 在测试用例内部手动划分步骤。       | `title` (str): 步骤名称。                                    | **用于 Test Case 层**。 当不调用 Page 方法，而是写断言或逻辑时使用。 |
|                              | **`allure.attach()`**       | **添加附件** 将截图、日志、HTML 嵌入报告。                   | `body`: 内容 `name`: 附件名 `attachment_type`: 类型          | **用于 `conftest.py` 或异常处理中**。 常用类型：`allure.attachment_type.PNG`。 |
| **4. 外部链接** (关联系统)   | **`@allure.link()`**        | **普通链接**                                                 | `url`: 链接地址 `name`: 显示名称                             |                   任何相关的参考文档链接。                   |
|                              | **`@allure.issue()`**       | **Bug 链接**                                                 | `url`: Bug ID/链接 `name`: 显示名称                          |  通常配置基础 URL 后只填 ID。用于标记该用例曾出现过的 Bug。  |
|                              | **`@allure.testcase()`**    | **用例库链接**                                               | `url`: 用例 ID/链接                                          |           关联到 Excel 或在线用例管理系统的地址。            |



















## 四、Jenkins持续集成工具



jenkins密码：

```
530fd4f064d74c70bc053e7aff3a2365
```



### CI/CD 

**CI：持续集成 (Continuous Integration)**

- **是什么：** 开发人员频繁地将代码更改合并到主代码库中。
- **做什么：** 每次提交代码后，系统会自动执行构建和测试，以确保新代码不会引入错误。
  1. **自动构建：** 编译代码。
  2. **自动测试：** 运行单元测试、静态代码检查。
- **目的：** **“早发现，早修复”。** 防止一个人提交的烂代码搞崩整个系统。如果在这一步自动化测试失败（Failed），代码会被拒绝合并。

**CD：持续交付 / 持续部署 (Continuous Delivery / Deployment)**

这是 CI 的下一步，通常指以下两个概念之一（取决于公司的激进程度）：

1. **持续交付 (Continuous Delivery)：** 代码通过 CI 后，自动部署到测试环境，经过人工或自动化验收后，**随时处于可发布到生产环境中**。
2. **持续部署 (Continuous Deployment)：** 更进一步，代码只要通过了所有自动化测试，就**自动**发布给最终用户，全程无人干预。



**CI/CD流程**：开发提交代码到 Git -> Jenkins 自动检测 -> 自动拉取代码 -> 自动构建和执行 Pytest/Selenium 脚本代码 -> 自动发送邮件/钉钉报告给团队（实现‘早发现、早修复’的敏捷开发目标）。

**流程描述**：本地修改测试用例（业务代码）提交到git仓库；jenkins监控到Git仓库发生变化（poll、webhook），会自动拉取最新代码，启动执行测试框架；（如果配置好allure插件后）jenkins执行后置 Action生成测试报告；最后将执行结果以邮件或报告形式通知给团队成员。

| **传统测试**                 | **CI/CD 环境下的测试**                                     |
| ---------------------------- | ---------------------------------------------------------- |
| 开发写完代码后，打包发给你测 | 代码提交瞬间，自动化脚本立刻运行                           |
| 手工执行重复的回归测试       | 编写自动化脚本（Appium/Selenium/Pytest），让机器跑回归测试 |
| 发现 Bug 靠人工记录          | 发现 Bug 靠系统自动报警，直接定位到具体代码行              |
| 关注功能是否实现             | 关注自动化流水线的稳定性、测试覆盖率和执行效率             |









### Jenkins Pipeline

**1. 什么是 Jenkins Pipeline?**

​	Jenkins Pipeline 是一套运行于 Jenkins 上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现复杂的流程编排。它支持 **Pipeline as Code**（流水线即代码）的概念，通过 `Jenkinsfile` 描述整个持续集成/持续交付 (CI/CD) 过程。

**核心优势：**

- **代码化**：Pipeline 定义在 `Jenkinsfile` 中，随项目代码一起进行版本控制。
- **持久性**：Pipeline 的执行可以经受 Jenkins 主节点重启（而在重启后继续运行）。
- **可视化**：提供了各阶段的视图（如 Blue Ocean UI），方便查看执行状态。



**2. 核心基本概念**

Jenkins Pipeline 由以下四个核心部分组成：

| **概念**         | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| **Jenkinsfile**  | 一个文本文件，包含定义 Pipeline 的完整代码。通常存放在项目的源代码控制库（如 Git）的根目录下。 |
| **Node (节点)**  | Jenkins 环境中的机器（可以是 Master 主节点或 Agent 代理节点）。Pipeline 中的所有具体操作都在 Node 上执行。 |
| **Stage (阶段)** | Pipeline 的逻辑分组/主要部分。用于描述一个阶段性任务，例如 `Build` (构建)、`Test` (测试)、`Deploy` (部署)。 |
| **Step (步骤)**  | 最基本的执行单元。在 Stage 内部执行的具体指令或操作（如 `echo`, `sh`, `git` 等）。 |

 	以前在 Jenkins 网页上一个个点击配置（源代码管理、构建步骤等），这叫“Freestyle”模式。现在把这些配置写成代码放在 `Jenkinsfile` 里。这样做的好处是：配置随代码一起进行版本控制，谁改了流水线一目了然，且易于迁移。



**3. Pipeline 语法分类**

Jenkins Pipeline 支持两种语法形式：**声明式 (Declarative)** 和 **脚本式 (Scripted)**。

**3.1 声明式 Pipeline (Declarative)**

- **特点**：更现代、语法更严格、结构更清晰，官方推荐使用。
- **结构**：必须包含在 `pipeline {}` 块内。
- **优势**：支持语法检查，与 Blue Ocean 界面集成更好。

**3.2 脚本式 Pipeline (Scripted)**

- **特点**：基于 Groovy 语言的原本语法，提供极高的灵活性和控制力。
- **结构**：通常以 `node {}` 块开始。
- **优势**：适合非常复杂的逻辑，可以随意使用 Groovy 代码（循环、条件判断等）。



**4. 常见指令与关键字详解**

- **`pipeline`**：声明式 Pipeline 的最外层块。
- **`agent`**：指定流水线（或特定阶段）在哪里执行。
  - `agent any`：在任意可用节点上运行。
  - `agent none`：全局不指定，需在每个 stage 内部指定。
  - *(补充)* `agent { docker 'maven:3-alpine' }`：使用 Docker 容器作为执行环境。
- **`stages`**：包含一个或多个 `stage` 的序列。
- **`stage`**：定义具体的阶段（如 "Build"）。
- **`steps`**：定义阶段内要执行的一系列操作。
- **`echo`**：打印信息到控制台输出（类似于 Shell 的 echo 或 Python 的 print）。
- **`post`**：定义 Pipeline 运行结束后的操作（无论成功或失败）。
  - `success`：仅在当前阶段/流水线成功时运行。
  - `failure`：仅在失败时运行。
  - *(补充)* `always`：无论结果如何都运行（常用于清理工作）。
  - *(补充)* `aborted`：被手动取消时运行。







### Jenkins ”避坑指南“

**一、 系统与环境配置篇（基建）**

**1. Jenkins 安装方式的选择（致命坑）**

- **难题**：安装了 Jenkins 但死活打不开浏览器、唤不醒模拟器。
- **经验**：**做 UI 自动化（Selenium/Appium），严禁使用 MSI 安装成 Windows 服务！**
  - Windows 服务运行在“Session 0”（后台隔离会话），没有桌面交互权限。
  - **正解**：必须下载 `.war` 包，通过 `java -jar jenkins.war` 在命令行启动，这样 Jenkins 才能继承当前用户的桌面权限。

**2. HTTP Proxy 配置（网络坑）**

- **难题**：Jenkins 插件下载极慢，或者直接超时失败。
- **经验**：国内环境几乎必须配置代理。
  - **技巧**：利用本机的 Clash/V2Ray。Host 填 `127.0.0.1`，端口填代理软件的端口（如 `7890`）。
  - **避坑点**：**“No Proxy For” 一定要填 `localhost` 和 `127.0.0.1`**。否则 Jenkins 连自己内部的服务（如节点通信）也会走代理绕一圈，导致莫名其妙的连接中断。

**二、 源码管理配置篇** 

**1. 分支名称不匹配 **

- **难题**：点击构建直接报错 `Couldn't find any revision to build`。
- **经验**：
  - Jenkins 老版本默认拉取 `*/master`。
  - GitHub 新仓库默认主分支叫 `*/main`。
  - **技巧**：新建任务第一件事，确认 GitHub 上的默认分支名，然后同步修改 Jenkins 配置。

**2. 目录结构的差异**

- **难题**：本地 PyCharm 跑得好好的，Jenkins 一跑就报 `ModuleNotFoundError: No module named 'Appium'`。
- **经验**：
  - **原因**：PyCharm 项目根目录下往往包含包名目录，但 Jenkins 默认把代码平铺在 Workspace 根目录下，导致 `import` 路径层级错乱。
  - **正解**：使用 **"Check out to a sub-directory" (检出到子目录)** 功能。让 Jenkins 的文件结构强行和本地 PyCharm 保持一致（例如都放在 `Appium` 文件夹下）。

**三、 构建步骤配置篇**

**1. 依赖环境的“隔离与复用”**

- **难题**：`pip install` 下载慢，或者 Jenkins 用了系统自带的 Python 而不是 Anaconda 的环境。
- **经验**：不要指望 Jenkins 自动猜到你的环境。
  - **技巧**：直接使用 **绝对路径** 调用解释器。
  - 写 `D:\Anaconda3\envs\DL\python.exe run.py` 而不是 `python run.py`。这样既利用了本地配好的环境，又避免了反复安装依赖。

**2. 相对路径 vs 绝对路径**

- **难题**：代码里写了 `D:/Project/...`，换台电脑或换个 Workspace 就挂了。
- **经验**：代码中严禁出现盘符（C:/, D:/）。
  - **正解**：必须使用 `./testcases` 或 `os.path.join(base_dir, 'report')` 这样的相对路径。

**四、 构建后操作配置篇**

**1. Allure 报告的路径迷局**

- **难题**：报告生成了，但显示 "0 test cases" 或者 "Unknown"。
- **经验**：分清“原料”和“成品”。
  - **Path**：填原料路径（Pytest 生成 json 的那个文件夹，如 `Appium/MyDemoApp/report`）。**不要**填 Jenkins 生成 HTML 的那个 `allure-report` 目录。
  - **相对路径**：这里的 Path 也是相对于 Workspace 的，不要写绝对路径。

















## 五、Git版本控制



### 1、 创建版本库 (Repository)

| **命令**        | **参数解释**            | **实际例子**                                 | **用法**                                                   |
| --------------- | ----------------------- | -------------------------------------------- | ---------------------------------------------------------- |
| **`git clone`** | `<url>`: 远程仓库的地址 | `git clone https://github.com/user/repo.git` | 克隆远程版本库到本地。                                     |
| **`git init`**  | 无额外参数              | `git init`                                   | 在当前目录初始化`.git` 隐藏文件夹，把这个文件变成git仓库。 |



### 2、 修改和提交 (Modify & Commit)

| **命令**                 | **参数解释**                 | **实际例子**                 | **用法**                                 |
| ------------------------ | ---------------------------- | ---------------------------- | ---------------------------------------- |
| **`git status`**         | 无额外参数                   | `git status`                 | 查看当前工作区和暂存区的状态。           |
| **`git diff`**           | 无额外参数                   | `git diff`                   | 查看工作区相对于暂存区的变更内容。       |
| **`git add .`**          | `.` 代表当前目录下的所有改动 | `git add .`                  | 跟踪（添加）所有改动过的文件到暂存区。   |
| **`git add`**            | `<file>`: 指定的文件名       | `git add index.html`         | 跟踪（添加）指定的文件到暂存区。         |
| **`git mv`**             | `<old>`: 旧名；`<new>`: 新名 | `git mv old.js new.js`       | 文件改名。                               |
| **`git rm`**             | `<file>`: 文件名             | `git rm test.c`              | 从工作区和暂存区中删除文件。             |
| **`git rm --cached`**    | `<file>`: 文件名             | `git rm --cached config.txt` | 停止跟踪文件但保留在本地文件夹中。       |
| **`git commit -m`**      | `"message"`: 提交的说明信息  | `git commit -m "fix bug"`    | 提交暂存区的更改到本地仓库。             |
| **`git commit --amend`** | 无额外参数                   | `git commit --amend`         | 修改最后一次提交（如改信息或补交文件）。 |



### 3、 查看提交历史 (History)

| **命令**         | **参数解释**     | **实际例子**         | **用法**                                 |
| ---------------- | ---------------- | -------------------- | ---------------------------------------- |
| **`git log`**    | 无额外参数       | `git log`            | 查看完整的提交历史记录。                 |
| **`git log -p`** | `<file>`: 文件名 | `git log -p main.py` | 查看指定文件的详细提交历史和代码差异。   |
| **`git blame`**  | `<file>`: 文件名 | `git blame app.js`   | 以列表方式查看指定文件的每一行修改记录。 |



### 4、撤销与回退命令

| **命令**                       | **参数解释**                                | **实际例子**                   | **用法**                                                     |
| ------------------------------ | ------------------------------------------- | ------------------------------ | ------------------------------------------------------------ |
| **`git restore`**              | `<filename>`: 文件名                        | `git restore 999.txt`          | **撤销工作区的修改**。 把文件恢复成最近一次 commit 的样子（刚才写的代码会消失）。 |
| **`git restore`**              | `--staged <filename>`                       | `git restore --staged 999.txt` | **撤销暂存区（Unstage）**。 把你误 `git add` 的文件拿出来，但文件内容**保留**（变回红色的未暂存状态）。 |
| **`git reset`** (默认 --mixed) | `HEAD^`: 上一个版本 `<commit_id>`: 指定版本 | `git reset HEAD^`              | **回退版本，保留修改在工作区**。 Commit 记录消失，但你写的代码还在（变成未 `add` 状态）。适合“想重新提交”时用。 |
| **`git reset`**                | `--soft HEAD^`                              | `git reset --soft HEAD^`       | **回退版本，保留修改在暂存区**。 Commit 记录消失，代码还在且已经是绿色的（已 `add`）。适合“只是想改改提交注释”时用。 |
| **`git reset`**                | `--hard HEAD^`                              | `git reset --hard HEAD^`       | **【危险】彻底回退版本**。 Commit 记录消失，**所有修改的代码也全部物理删除**。适合“这版本彻底写烂了，不要了”时用。 |



### 5、 分支与标签 (Branch & Tag)

| **命令**                                                     | **参数解释**                 | **实际例子**             | **用法**                     |
| ------------------------------------------------------------ | ---------------------------- | ------------------------ | ---------------------------- |
| **`git branch`**                                             | 无额外参数                   | `git branch`             | 显示所有本地分支列表。       |
| **`git checkout`**                                           | `<branch/tag>`: 分支或标签名 | `git checkout v1.0`      | 切换到指定的分支或标签。     |
| **`git branch`**                                             | `<new-branch>`: 新分支名     | `git branch dev`         | 创建一个新的分支。           |
| **`git branch -d`**                                          | `<branch>`: 分支名           | `git branch -d old-feat` | 删除指定的本地分支。         |
| **`git branch -M main`**                                     |                              |                          | 重命名分支 (规范化)          |
| **`git tag`**                                                | 无额外参数                   | `git tag`                | 列出所有本地已有的标签。     |
| **`git tag -a v1.0 -m "这是我的第一个正式发布版本，包含了登录功能"`** | `<tagname>`: 标签名称        | `git tag v2.0`           | 基于最新提交创建一个新标签。 |
| **`git tag -d`**                                             | `<tagname>`: 标签名称        | `git tag -d v1.1`        | 删除指定的标签。             |



### 6、 合并与衍合 (Merge & Rebase)

| **命令**         | **参数解释**                   | **实际例子**          | **用法**                             |
| ---------------- | ------------------------------ | --------------------- | ------------------------------------ |
| **`git merge`**  | `<branch>`: 要合并进来的分支名 | `git merge feature-a` | 将指定分支合并到当前分支。           |
| **`git rebase`** | `<branch>`: 目标基准分支       | `git rebase main`     | 将当前分支的更改衍合到指定分支之后。 |



### 7、 远程操作 (Remote)

| **命令**              | **参数解释**                         | **实际例子**                  | **用法**                                                     |
| --------------------- | ------------------------------------ | ----------------------------- | ------------------------------------------------------------ |
| **`git remote -v`**   | 无额外参数                           | `git remote -v`               | 查看当前连接的远程库简要信息。                               |
| **`git remote show`** | `<remote>`: 仓库代号（如 origin）    | `git remote show origin`      | 查看指定远程库的详细信息。                                   |
| **`git remote add`**  | `<remote>`: 代号；`<url>`: 地址      | `git remote add origin <url>` | 关联远程仓库，建立与Github项目的连接，在 Git 配置文件（`.git/config`）里写了一行记录，告诉本地的 Git 往哪里推。 |
| **`git fetch`**       | `<remote>`: 远程库名                 | `git fetch origin`            | 从远程库获取最新代码，但不自动合并。                         |
| **`git pull`**        | `<remote>`: 库名；`<branch>`: 分支名 | `git pull origin main`        | 保持同步，把项目有可能的更新改动重新合并拉取到本地，防止我不知道。 |
| **`git push`**        | `<remote>`: 库名；`<branch>`: 分支名 | `git push origin main`        | 保持同步，把更新后的 main 推送到 GitHub。                    |
| **`git push`**        | `:<branch/tag-name>`: 冒号加名       | `git push origin :old-branch` | 删除远程分支或标签。                                         |
| **`git push --tags`** | 无额外参数                           | `git push origin --tags`      | 一次性推送所有本地标签。                                     |



​	如果在使用 git merge 或 git pull 时遇到了 **Merge Conflict (合并冲突)**，这意味着 Git 无法自动决定如何保留代码。这时需要手动打开文件修改冲突部分，然后重新执行 add 和 commit。



