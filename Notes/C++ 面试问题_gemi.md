## C++ 面试问题_gemi



### 常用关键字

#### 1. `static` 关键字有什么作用？

`static` 主要用于改变变量的**生命周期**和**链接属性**。

- **修饰局部变量**：使其生命周期延长至整个程序结束，只初始化一次。
- **修饰全局变量/函数**：将其作用域限制在当前源文件内（内部链接），避免命名冲突。
- 修饰类成员：
  - **成员变量**：成为**类变量**，被所有对象共享。
  - **成员函数**：成为**类函数**，不接收 `this` 指针，只能访问静态成员。
  - （`this` 指针存在于类的每个非静态成员函数中，指向当前调用成员函数的**对象本身**；由于静态成员函数不属于特定的对象，而是属于整个类，因此没有“当前对象”的概念）

#### 2. `const` 关键字有什么作用？

`const` 用于定义一个**只读的、不可修改**的实体。

- **修饰变量**：定义一个必须初始化的常量。
- **修饰指针**：`const int*` (指向常量的指针) vs `int* const` (指针本身是常量)。
- **修饰函数参数**：`const T&` 是高效且安全传递大对象的首选方式，防止函数修改实参。
- **修饰成员函数**：保证该函数不修改任何类成员变量，`const` 对象只能调用 `const` 成员函数。

#### 3. `volatile` 关键字有什么作用？

`volatile` 是一个类型限定符，用于告知编译器：**该变量的值可能在程序之外被意外修改（例如由硬件、操作系统、其他线程或中断服务程序修改），因此编译器不应对其进行优化**。

- **核心作用**：**防止编译器优化**，**确保每次访问都直接从内存中读取或写入**。
- **主要用途**：多线程编程（现多用 `std::atomic`）、中断处理、访问硬件寄存器。

#### 4. `class` 和 `struct` 的区别？

在C++中，唯一的**语法区别**是默认的访问权限和继承方式。

- **`class`**：默认访问权限和继承方式是 `private`。

- **`struct`**：默认访问权限和继承方式是  `public`。

- **用法上**：`class`  通常用于实现面向对象的思想，它**强调封装和抽象**，即把数据和操作数据的方法组合在一起，隐藏对象的属性和实现细节。

  `struct` 不强调封装和抽象，主要用于**聚合数据**，即把一堆数据成员打包在一起，作为一个简单的数据结构。

### 内存管理 & 指针

#### 5. `new/delete` 和 `malloc/free` 的区别？

`new/delete` 是C++**操作符**，支持面向对象；`malloc/free` 是C库**函数**，只管理内存。

- **构造/析构**：`new/delete` 会自动调用对象的**构造函数和析构函数**；`malloc/free` 不会。
- **类型安全**：`new` 返回具体类型的指针，类型安全；`malloc` 返回 `void*`，需要手动转换。
- **重载**：`new/delete` 可以被重载以实现自定义内存管理；`malloc/free` 不可重载。
- **分配对象**：`new[]` 可分配单个对象或对象数组；`malloc`只能分配原始字节块 。

#### 6. 指针和引用的区别？

| 特性       | 指针 (Pointer)         | 引用 (Reference)               |
| :--------- | :--------------------- | :----------------------------- |
| **本质**   | 存储**内存地址**的变量 | 对象的**别名**                 |
| **空值**   | 可为空 (`nullptr`)     | **不能为空**，必须初始化       |
| **重定向** | 可改变指向             | **不可改变**，一旦初始化便固定 |

#### 7. 引用的优势有哪些？

引用比指针**更安全、高效**。

- **安全**：无空引用（必须初始化）、不可重定向（行为可预测）。
- **简洁**：使用时像普通变量，无需 `*` 或 `&` 等符号，可读性高。
- **高效**：作为函数参数传递大对象时，避免了拷贝开销，效率与指针相当。

#### 8. 介绍一下智能指针？

智能指针是利用 **RAII** (资源获取即初始化) 技术**自动管理动态分配的内存**，当智能指针对象离开作用域时，其析构函数会自动被调用，从而释放它所管理的内存空间，防止内存泄漏。

- C++11 标准库主要提供了三种智能指针：
  1. **`std::unique_ptr` (独占指针)**
     - **核心特点**：**独占所有权**。保证在任何时刻，只有一个 `unique_ptr` 能管理该内存。当 `unique_ptr` 对象离开作用域被销毁时，它所管理的内存会自动被 `delete`。它禁止拷贝，只能通过 `std::move` **转移所有权**。
     - **使用场景**：它是轻量、高效的零成本抽象，是**默认首选**的智能指针。
  2. **`std::shared_ptr` (共享指针)**
     - **核心特点**：**共享所有权**。允许多个 `shared_ptr` 指向并共同管理同一块内存。内部使用**引用计数**机制。每当有一个新的 `shared_ptr` 指向资源时，引用计数加一；每当一个 `shared_ptr` 被销毁时，引用计数减一。当引用计数变为零时，内存才会被自动释放。
     - **使用场景**：适用于多个对象需要共同拥有和管理同一份资源的场景。
  3. **`std::weak_ptr` (弱指针)**
     - **核心特点**：**非拥有（观察者）指针**。它是一种**不控制资源生命周期**的智能指针。指向一个由 `shared_ptr` 管理的资源，但**不增加引用计数**。
     - **使用场景**：它的主要作用是**监视**一个 `shared_ptr`，并且**解决 `shared_ptr` 之间因循环引用**而导致的内存泄漏问题。

| 智能指针          | 所有权模型       | 核心作用                                                     | 主要特点                                                     |
| :---------------- | :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `std::unique_ptr` | 独占所有权       | 确保一个对象只有一个拥有者。当`unique_ptr`被销毁时（例如离开作用域），它所指向的对象也会被自动删除。 | - 轻量级，开销与原始指针相近。                                      - 不可复制，但可以通过`std::move`转移所有权。          - 是管理动态分配资源的默认首选。 |
| `std::shared_ptr` | 共享所有权       | 允许多个`shared_ptr`共同拥有同一个对象。内部通过引用计数来跟踪拥有者的数量。当最后一个`shared_ptr`被销毁时，对象才会被删除。 | - 允许多个指针指向同一资源，适用于资源需要被多个部分共享的场景。                                                                       - 引用计数会带来一定的性能开销。                                   - 可能会导致循环引用问题。 |
| `std::weak_ptr`   | 非拥有（观察者） | 作为`shared_ptr`的助手，它提供对`shared_ptr`所管理对象的非拥有性（弱）引用。它不增加引用计数。 | - 用于打破`shared_ptr`之间的循环引用。                       - 不能直接访问所指向的对象，必须通过`lock()`方法获取一个临时的`shared_ptr`来安全地访问。如果对象已被销毁，`lock()`会返回一个空的`shared_ptr`。 |

总结：

- 当你需要一个指针独占一个资源时，使用`std::unique_ptr`。
- 当你需要多个指针共享一个资源的所有权时，使用`std::shared_ptr`。
- 当你需要观察一个由`std::shared_ptr`管理的对象，但又不想影响其生命周期时（特别是为了解决循环引用），使用`std::weak_ptr`。

------

### 面向对象编程 (OOP)

#### 9. 介绍一下面向对象三大特性？

- **封装 (Encapsulation)**：**信息隐藏**。将数据和操作数据的方法进行结合，隐藏对象的属性和实现细节，通过对外公开接口和对象进行交互。
- **继承 (Inheritance)**：**代码重用**。继承机制是使父类定义的代码可以复用的重要手段，允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类称为派生类。
- **多态 (Polymorphism)**：**同一接口，多种实现**。就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。通常用基类的指针指向派生类的对象，并在运行时根据对象的实际类型来调用相应的方法（运行时多态）。

#### 10. 重载 (Overloading) 和重写 (Overriding) 的区别？

- **重载**：是“名字相同，参数不同”的多个函数，发生在同一个类中。方便调用，提供功能相似但参数不同的版本；属于**编译时多态**。
- **重写**：是“签名完全相同”的函数，发生在子类和父类之间，用于实现不同的行为。子类根据自身特性，实现与父类不同的行为；属于**运行时多态**。

#### 11. 什么是虚函数？其原理是什么？

虚函数是用于实现**运行时多态**的成员函数，在基类中用 `virtual` 关键字声明。

- 原理：通过虚函数表 (v-table)实现。
  - 编译器为每个包含虚函数的类创建一个 v-table，存储该类所有虚函数的地址。
  - 每个该类的对象都有一个**虚函数指针 (v-ptr)**，指向其类的 v-table。
  - 当使用基类指针指向派生类对象时，首先会找到实例对象中隐含的虚表指针 v-ptr ，再通过 v-ptr 找到对应派生类的 v-table，从中查找正确的虚函数地址进行调用。这个过程在运行时完成，称为**动态绑定**。

### 标准模板库 (STL)

#### 12. `map` 和 `unordered_map` 的区别？

- 底层实现：
  - `map`：基于**红黑树**，是有序的。
  - `unordered_map`：基于**哈希表**，是无序的。
- 性能：
  - `map`：所有操作的**时间复杂度稳定在 O(log N)**。
  - `unordered_map`：在哈希函数理想的情况下，增删查的**平均时间复杂度为 O(1)**，最坏为 O(N)。
- 适用场景：
  - `map`：需要**有序**存储键值对，或对性能稳定性要求高的场景。
  - `unordered_map`：追求**最高查找效率**，且对顺序无要求的场景。

### C++ 核心语言特性 (补充)

#### 13. `explicit` 关键字有什么作用？

`explicit` 关键字用于修饰**类的单参数构造函数**（或多个参数但除第一个外都有默认值的构造函数）。

- **核心作用**：**禁止隐式类型转换**。防止编译器自动使用该构造函数将一个值转换为类对象，让代码意图更明确，避免意外的类型转换。

```
class MyString {
public:
    explicit MyString(int size); // 禁止 MyString s = 10; 这样的隐式转换
};
```

#### 14. `final` 和 `override` 关键字有什么作用？

这两个关键字是C++11引入的，用于增强继承控制。

- `override`：在子类中明确表示一个成员函数是对父类虚函数的重写。
  - **作用**：让编译器检查重写是否合法（函数签名是否匹配等），防止因拼写错误等导致重写失败。
- `final`：
  - **修饰虚函数**：表示该虚函数**不能再被任何子类重写**。
  - **修饰类**：表示该类**不能被任何其他类继承**。

#### 15. C++中四种 `cast` (类型转换) 的区别？

C风格转换`(type)value`**功能强大但过于笼统**，它可能进行下述四种转换中的任何一种，**难以明确其具体意图**，存在潜在风险。

C++的四种类型转换运算符可以**显式地写明转换意图**，将**风险暴露在代码层面**，从而**增强代码的可读性和安全性**。

1. **`static_cast` (静态转换)**
   - **作用**：用于**编译时**已知的、**相关类型**之间的转换。
   - **特点**：提供编译期类型检查，无运行时开销。主要用于数值类型转换、类层次结构中的**安全上行转换**（派生类->基类）和**不安全的下行转换**（基类->派生类，程序员需保证转换的正确性）。
   - **场景**：`int` 转 `double`，`void*` 指针的转换，派生类指针转基类指针。
2. **`dynamic_cast` (动态转换)**

   - **作用**：用于类层次结构中**安全**的下行或交叉转换。
   - **特点**：**运行时**检查类型安全，会有额外的开销。依赖 RTTI（运行时类型信息）。只适用于**多态类型**（基类必须有虚函数）。如果转换失败，对指针返回 `nullptr`，对引用则抛出 `std::bad_cast` 异常。
   - **场景**：当需要通过基类指针安全地调用派生类特有的方法时。
3. **`const_cast` (常量转换)**
   - **作用**：专门用于**移除或添加**变量的 `const` 或 `volatile` 属性。
   - **特点**：它是唯一能改变 `const` 属性的C++强制转换。但若试图修改一个**原本就定义为 `const`** 的对象，其行为是**未定义的**。
   - **场景**：主要用于适配不接收 `const` 参数的旧版API，但你确信该函数不会修改数据。
4. **`reinterpret_cast` (重解释转换)**
   - **作用**：用于任意类型指针或整数之间的**底层位模式**的重新解释。
   - **特点**：最危险的转换，无任何类型检查，可移植性差。它告诉编译器“相信我，我知道自己在做什么”，直接进行二进制层面的转换。
   - **场景**：处理底层硬件、不同类型指针间的强制转换、指针与整数间的转换等低级操作。

### STL (补充)

#### 16. `vector` 的底层实现和扩容机制？

- **底层实现**：一块**连续的内存空间**（类似动态数组）。
- **优点**：支持随机访问（O(1)）。
- 扩容机制：当 `size()` 达到 `capacity()` 时，`vector` 会：
  1. 申请一块**更大的**内存空间（通常是原容量的 1.5 或 2 倍）。
  2. 将旧内存中的元素**移动或拷贝**到新内存中。
  3. **释放**旧的内存空间。
- **注意**：扩容会导致所有**迭代器、指针和引用失效**。

**vector 扩容时如何判断哪些元素需要移动，哪些需要拷贝? 如果是拷贝的话是深拷贝还是浅拷贝？**

**1.如何判断移动还是拷贝？**

​	通过元素的**移动构造函数**是否被标记为 `noexcept`来判断，`vector` 扩容时，只有当元素的**移动构造函数被显式标记为 `noexcept`** ，**承诺不会抛出异常时**，**会优先使用`move` 来移动元素**；否则，**为了保证异常安全**，会保守地选择拷贝元素。

**2.如果是拷贝，是深拷贝还是浅拷贝？**

​	**这完全取决于元素类型自己实现的拷贝构造函数**。`vector`本身不决定拷贝的深浅，**它只是调用其元素的拷贝构造函数**，对于管理资源的自定义类型，程序员必须自己实现正确的深拷贝逻辑。

#### 17. `list` 的底层实现？

- **底层实现**：一个**双向链表**。
- **优点**：在任意位置插入和删除元素的时间复杂度都是 **O(1)**。
- **缺点**：不支持随机访问（访问第n个元素需要 O(N) 时间），且每个元素需要额外的指针开销。

### 多线程

#### 18. 介绍一下 C++ 中的互斥锁 (Mutex)？

互斥锁 (`std::mutex`) ：确保同一时间只有一个线程能访问**共享资源**、防止多线程同时访问造成数据竞争。

- **工作机制**：线程在访问共享资源前，必须先**加锁 (`lock`)**。如果锁已被其他线程持有，则当前线程会被阻塞，直到锁被释放。访问结束后，必须**解锁 (`unlock`)**。
- RAII包装：通常推荐使用 `std::lock_guard` 或 `std::unique_lock` 来管理互斥锁。它们利用 RAII 技术，在构造时自动加锁，在析构时（离开作用域时）自动解锁，从而避免忘记解锁导致的死锁问题。
  - `std::lock_guard`：简单、高效，但功能单一。
  - `std::unique_lock`：更灵活，支持延迟加锁、条件变量等高级操作，但开销稍大。

#### 19. 什么是死锁？如何避免？

- **死锁 (Deadlock)**：指两个或多个线程因争夺资源而陷入一种**无限等待**的状态，导致所有线程都无法继续执行的现象。
- 产生死锁的四个必要条件：
  1. **互斥**：资源一次只能被一个线程使用。
  2. **请求与保持**：一个线程在等待其他资源时，继续持有已占有的资源。
  3. **不可剥夺**：已经分配给线程的资源不能被其他线程强行夺取。
  4. **循环等待**：存在一个线程等待链，`T1` 等待 `T2`，`T2` 等待 `T3`，...，`Tn` 等待 `T1`。
- 如何避免：
  1. **破坏请求与保持条件**：一次性申请所有需要的资源。
  2. **破坏不可剥夺条件**：允许线程主动释放已占有资源（实现复杂）。
  3. **破坏循环等待条件**：**按固定顺序获取锁**。这是最常用和最简单有效的方法。例如，所有线程都必须先锁A，再锁B。
- 死锁怎么调试：
  1. **日志分析**：打印/分析线程栈，查看线程卡在哪些锁上。
  2. **使用调试器**：如 gdb、Visual Studio 调试器等。
  3. **使用专用锁分析工具**：使用Helgrind（Valgrind）、ThreadSanitizer 等检测死锁。

### 其他综合问题

#### 20. 什么是 RAII？

**RAII (Resource Acquisition Is Initialization)**，即“资源获取即初始化”。

- **核心思想**：将资源的生命周期与**对象的生命周期**绑定。在对象的**构造函数**中获取资源（如分配内存、打开文件、加锁），在**析构函数**中释放资源。
- **优势**：利用C++的**栈对象自动析构**机制，保证资源无论在何种情况下（正常退出、异常抛出等）都能被**自动、正确地释放**，极大地增强了代码的**异常安全性**，并有效防止了资源泄漏。智能指针和锁守卫 (`std::lock_guard`) 都是 RAII 的典型应用。

**RAII如何配合异常处理流程：**

1. 当函数作用域内发生异常时，栈展开（stack unwinding）会自动调用局部对象的析构函数；
2. 从而保证资源（内存、文件句柄、锁等）被安全释放，不会泄漏。

一句话总结：**RAII 利用对象生命周期管理资源，使得即使在异常抛出时，资源也能被自动释放。**

#### 21. 介绍一下右值引用和移动语义？

引用是 C++ 中一个变量的“别名”。C++11 之前，我们只有左值引用，右值引用是 C++11 引入的重要特性，旨在**减少不必要的拷贝，提升性能**。

**首先明确一点，无论是左值引用还是右值引用，都是给一段空间取别名，并没有开辟新的内存空间。**

| 特性                 | 左值引用 (`&`)                                               | 右值引用 (`&&`)                                              |
| :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **绑定对象**         | **只能绑定到左值**。（例外：`const`左值引用可以绑定到右值）  | **只能绑定到右值**。                                         |
| **内存关系**         | 左值引用标识的是与原对象共享的、相同的一块内存空间。         | 右值引用通常绑定到一个**“临时对象”**，标识的是这个即将销毁的临时对象的内存空间，延长了它的生命周期 |
| **对生命周期的影响** | 不影响其绑定对象的生命周期。                                 | 将本应立即销毁的临时对象的**生命周期延长**至与引用自身相同。 |
| **引用自身的属性**   | 一个命名的左值引用**本身是左值**。                           | 一个命名的右值引用**本身也是左值**！（因为它有名字，可以被取地址，符合左值的定义） |
| **主要设计目的**     | 作为别名，用于**修改或访问**已有对象，避免拷贝（尤其用于函数传参）。 | 识别出可以被“窃取（移动）”资源的临时对象，实现**移动语义**，避免昂贵的深拷贝，提升性能。 |
| **典型应用场景**     | 1. 函数参数传递：`void func(MyType& obj);`2. 拷贝构造/赋值：`MyType(const MyType& other);` | 1. 移动构造/赋值：`MyType(MyType&& other);`<br>2. 接收函数返回的临时对象：`MyType&& var = createMyType();` |

- **右值引用 (`&&`)**：一种新的引用类型，专门用于**绑定到即将销毁的临时对象（右值）**。
- **移动语义 (Move Semantics)**：允许将资源（如动态分配的内存、文件句柄）从一个对象“**转移**”或“**窃取**”到另一个对象，而不是进行深拷贝。
- **实现**：通过定义**移动构造函数**和**移动赋值运算符**来实现。这些函数接受一个右值引用作为参数。
- **`std::move`**：一个函数模板，它并不进行任何移动操作，而是**将一个左值强制转换为右值引用**，从而使其能够调用移动构造函数或移动赋值运算符。就是告诉编译器，把这个左值当成一个临时的右值来处理，可以拿走它的所有资源（比如指向它的指针）到另一个对象，我不再关心这个对象原来的值了，它现在处于一个‘有效但未指定’的状态。但在它被重新赋值之前，不应该再使用它的旧值。

#### 22. 什么是 Lambda 表达式？

Lambda 表达式是 C++11 引入的一种**创建匿名函数**的便捷方式。

- Lambda 表达式的基本语法是：
  `[捕获列表](参数列表) -> 返回类型 { 函数体; }`

- [捕获列表]，用于指定 Lambda表达式可以访问的外部变量，以及是按值还是按引用的方式访问。捕获列表可以为空，表示不访问任何外部变量，也可以使用默认捕获模式 `&` 或 `=` 来表示按引用或按值捕获所有外部变量。

- 1. Lambda表达式相比于普通函数和普通类，有以下几个优点：
  
     **简洁**：Lambda表达式**可以省略函数名和类名，直接定义和使用**，使得代码更加简洁和清晰。
     **灵活**：Lambda表达式**可以捕获外部变量，可以作为函数参数**，也可以作为函数返回值，使得代码更加灵活和方便。
     **安全**：Lambda表达式**可以控制外部变量的访问方式，可以避免全局变量的定义，可以避免悬空指针和无效引用的产生**，使得代码更加安全和稳定。

### 底层机制与内存模型

#### 23. 虚析构函数的作用是什么？为什么要用它？

- **作用**：确保通过**基类指针**删除一个**派生类对象**时，能够正确地调用派生类的析构函数，从而**彻底释放所有资源**。
- **为什么要用**：当通过基类指针删除派生类对象时，如果基类的析构函数不是虚函数，那么 `delete base_ptr;`会导致未定义的行为；并且只会调用基类的析构函数，而不会调用派生类的虚构函数，导致为派生类中分配的资源（如申请的内存）无法被释放。
- 将基类的析构函数声明为 `virtual`时，编译器为其生成的虚函数表中就包含了虚析构函数的地址；使用一个派生类继承该类时，编译器会为派生类生成属于其自身的虚函数表（这个表会复制基类的虚函数表内容），在派生类中重写析构函数时，会更新虚函数表中原本基类的虚析构函数的地址；通过基类指针删除派生类对象时，首先会找到对象中隐含的虚表指针，通过虚表指针找到属于派生类的虚函数表，从而先调用派生类的析构函数，再调用基类的析构函数，彻底释放所有资源。
- **黄金法则**：当一个类可能被用作基类（即可能被继承）时，应将其析构函数声明为 `virtual`。

#### 24. 内存分区、栈和堆的区别？

| 内存分区                             | 存储内容               | 分配方式                       | 生存周期                                             | 特点                           |
| :----------------------------------- | :--------------------- | :----------------------------- | :--------------------------------------------------- | ------------------------------ |
| 栈区                                 | 局部变量、形参、返回值 | 栈区由编译器自动分配释放       | 分配再栈上内存的随函数调用结束或作用域结束而自动释放 | 访问速度快，空间有限           |
| 堆区                                 | 动态分配的对象或内存块 | 由程序员手动分配和释放         | 由程序员控制，直到手动释放为止                       | 空间大，灵活，需手动管理       |
| 全局/静态存储区(`.data`段  `.bss`段) | 全局变量和静态变量     | 程序启动时、main函数执行前分配 | 整个程序运行期间有效                                 | 生命周期长，初始化在程序启动前 |
| 常量区(`.rodata`段)                  | 字符串、数字等字面常量 | 编译时分配                     | 整个程序运行期间有效                                 | 只读                           |
| 代码区(`.text`段)                    | 存放函数体的二进制代码 | 编译时分配                     | 整个程序运行期间有效                                 | 只读                           |

- **全局区分为两个段：**
  - `.data`段：存储**已初始化**的全局/静态变量。由于初始值需要存入文件，**会增加可执行文件的大小**。
  - `.bss`段：存储**未初始化**的全局/静态变量。只记录所需空间大小，**不占用可执行文件实际空间**。程序启动时由系统自动清零。

#### 25. C++ 对象的内存布局是怎样的？（针对包含虚函数的情况）

- **无虚函数**：对象的内存布局仅包含**非静态成员变量**，其顺序通常与声明顺序一致（受内存对齐影响）。
- 有虚函数：
  1. **虚函数指针 (v-ptr)**：编译器会在对象的内存布局的**最前端**（通常是）插入一个**虚函数指针**。这个指针指向该类对应的**虚函数表 (v-table)**。
  2. **成员变量**：v-ptr 之后是类的非静态成员变量。
- **虚函数表 (v-table)**：是一个静态的全局数组，每个包含虚函数的类都有一个。它存储了该类所有虚函数的地址。子类的 v-table 会复制父类的 v-table，并用自己重写的函数地址覆盖相应条目。

#### 26. 什么是内存对齐 (Memory Alignment)？

- **定义**：CPU 访问内存时，并非逐字节访问，而是以字（Word，通常是4或8字节）为单位。内存对齐是指编译器将数据**存放在其自身对齐数的整数倍的地址上**，以提高 CPU 的访问效率。（对齐数 = “编译器默认的对齐数” 与 “该成员类型大小” 的较小值）
- **为什么要对齐**：如果数据未对齐（如 `int` 存储在地址 `0x1003` 而非 `0x1004`），CPU 可能需要 **分两次读取**（先读 `0x1000-0x1003`，再读 `0x1004-0x1007`），然后拼接数据，才能访问一个变量，导致性能下降。某些架构平台（如 ARM）甚至**强制要求对齐访问**。
- **`sizeof` 的影响**：内存对齐会导致结构体或类的 `sizeof` 结果可能**大于**其所有成员大小的总和，因为编译器会插入**填充字节 (padding)** 来保证每个成员都对齐。

### 设计模式

#### 27. 什么是单例模式 (Singleton Pattern)？如何实现？

- **定义**：一种保证一个类**只有一个实例**，并提供一个全局访问点来访问该实例的设计模式。
- **应用场景**：全局配置、日志记录器、数据库连接池等需要全局唯一对象的场景。
- 如何实现（线程安全的懒汉式）：
  1. 将**构造函数、拷贝构造函数、赋值运算符**声明为 `private` 或 `delete`，防止外部创建和复制实例。
  2. 提供一个**静态的、公共的**获取实例的方法（如 `getInstance()`）。
  3. 在该方法内部，使用一个**静态局部变量**来创建和持有实例。

```
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance; // C++11 保证静态局部变量的初始化是线程安全的
        return instance;
    }
private:
    Singleton() = default;
    ~Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};
```

#### 28. 什么是工厂模式 (Factory Pattern)？

- **定义**：一种创建型设计模式，它提供一种**创建对象的最佳方式**，而无需向客户端暴露创建逻辑。客户端只需知道所需产品的接口，而无需关心其具体实现。
- **核心思想**：将**对象的创建**与**对象的使用**相分离。
- **简单工厂**：一个工厂类，根据传入的参数来决定创建并返回哪种具体的产品实例。
- **工厂方法**：定义一个用于创建对象的接口（工厂基类），但让子类（具体工厂）决定实例化哪一个类。使得一个类的实例化延迟到其子类。

------

### C++ 新特性与高级话题

#### 29. `auto` 和 `decltype` 的区别？

`auto` 和 `decltype` 都是 C++11 引入的类型推导关键字。

- `auto`：根据**初始化表达式**来推断变量的类型。`auto` 会忽略顶层的 `const` 和引用。

  ```
  const int x = 10;
  auto y = x; // y 的类型是 int，而不是 const int
  ```

- `decltype`：根据任意表达式**推导出其切确类型**，但不计算表达式的值。它会**保留**顶层的 `const` 和引用，能精确地反映表达式的类型。

  ```
  const int& x = 10;
  decltype(x) y = x; // y 的类型是 const int&
  ```

| **特性**                  | **`auto`**              | **`decltype`**                  |
| ------------------------- | ----------------------- | ------------------------------- |
| **推导依据**              | 变量的初始化表达式      | 任意表达式的类型                |
| **是否保留 `const`/引用** | 忽略顶层 `const` 和引用 | 完全保留（包括 `const` 和引用） |
| **是否需要初始化**        | 必须初始化              | 无需初始化（仅推导类型）        |
| **典型用途**              | 简化变量声明            | 模板元编程、返回类型推导        |

#### 30. 什么是完美转发？`forward` 函数是什么？

- **定义**：是一种技术，允许在函数模板中将其接收到的参数**原封不动地转发**给另一个函数。这里的“原封不动”指的是参数的**左值/右值属性**和 **`const`/`volatile` 属性**都保持不变。
- 如何实现：通过**模板参数推导**和 **`std::forward`** 结合使用。
  - 函数模板的参数类型通常写成**通用引用 (Universal Reference)**，形式为 `T&&`。
  - 在函数内部，使用 `std::forward<T>(arg)` 来转发参数。

（1）`std::forward` 函数是什么？

- `std::forward` 是一个**条件转换工具**，专门用于在模板中实现**完美转发**。
- 作用：**根据模板参数推导出的类型，保留函数参数的原始值类别（左值或右值），然后再传递给另一个函数。**

（2）为什么不用 `std::forward` 会变成左值？

- **在 C++ 中，任何拥有名字的对象，当被使用时都是一个左值，即使其类型是右值引用。**
- **不用 `forward`，参数在传递时会丢失右值属性，从而被当成左值。**

```
void some_function(int&);  // 重载1：接收左值
void some_function(int&&); // 重载2：接收右值

template<typename T>
void wrapper(T&& param) { // param 是一个转发引用
    // 在这里，无论传进来的是左值还是右值，'param' 本身都是一个左值！
    //因为它有名字 "param"。

    // 错误的做法：
    some_function(param); // 因为 param 是左值，所以永远只会调用 some_function(int&)

    // 正确的做法：
    some_function(std::forward<T>(param)); // 'param' 被恢复为其原始的值类别
                                          // 如果传给 wrapper 的是右值，这里就调用 some_function(int&&)
                                          // 如果传给 wrapper 的是左值，这里就调用 some_function(int&)
}

int main() {
    int x = 10;
    wrapper(x);      // T 推导为 int&, forward 转发左值
    wrapper(20);     // T 推导为 int,  forward 转发右值
}
```

### 现代 C++ 特性 (C++11/14/17/20)

#### 31. `std::function` 和函数指针有什么区别？

`std::function` 是 C++11 引入的一个**通用的、多态的函数包装器**。

- **函数指针**：只能指向**特定签名**的**普通函数**或**静态成员函数**。
- `std::function`：更加强大和灵活，它可以包装**任何可调用对象 (Callable Object)**，包括：
  - 普通函数指针
  - Lambda 表达式
  - 函数对象 (Functor，重载了 `operator()` 的类)
  - 成员函数指针 (需配合 `std::bind` 或 Lambda 捕获 `this`)
- **核心区别**：`std::function` 是一个**类模板**，它通过**类型擦除 (Type Erasure)** 技术在运行时存储和调用不同类型的可调用对象，因此会带来一些性能开销。而函数指针是一个纯粹的指针，非常轻量。

#### 32. 什么是 SFINAE？它有什么用？

**SFINAE (Substitution Failure Is Not An Error)**，即“替换失败并非错误”。

- **核心思想**：在 C++ 模板实例化过程中，当编译器尝试用一个具体的类型去替换模板参数时，如果这个替换导致了无效的代码（如调用了不存在的成员函数），编译器**不会报错**，而是简单地**放弃这个模板重载**，并继续寻找其他可行的重载。
- 用途：这是 C++ **模板元编程**的基石。它主要用于：
  1. **基于类型特性选择模板**：可以编写多个同名模板，但通过 SFINAE 让它们只对满足特定条件的类型有效（例如，一个模板只对整数类型有效，另一个只对类类型有效）。
  2. **实现类型萃取 (Type Traits)**：如 `std::enable_if`，用于在编译期根据条件启用或禁用某个模板。

#### 33. `constexpr` 和 `const` 有什么区别？

- **`const`**：表示**运行时常量**，确保一个对象是**只读的 **，在**运行时**该对象的值不会被改变。
- `constexpr`：表示**编译时常量**，确保一个表达式或函数不仅是只读的，而且其值**必须在编译期确定**，是一个更强的约束。
  - **修饰变量**：该变量必须在编译期求值，成为一个真正的**编译期常量**。
  - **修饰函数**：表示该函数如果传入的参数都是编译期常量，那么它就可以在编译期执行并返回一个编译期常量结果。这使得我们可以在编译期进行更复杂的计算。
- **总结**：`constexpr` 是比 `const` 更强的约束，它强调的是**编译期可知性**，而 `const` 只强调**运行时不可变性**。

------

### 并发编程 (深入)

#### 34. 什么是条件变量 (`std::condition_variable`)？

条件变量是一种同步原语，它允许线程**等待某个特定条件成立**。

- 工作机制：它总是与一个**互斥锁 (`std::mutex`)** 配合使用。
  1. 一个线程（消费者）获取锁，然后检查条件是否满足。
  2. 如果不满足，它会调用 `wait()` 方法。`wait()` 会**原子地释放锁**并让线程**进入阻塞状态**。
  3. 另一个线程（生产者）在改变了条件后，会获取同一个锁，然后调用 `notify_one()` 或 `notify_all()` 来唤醒一个或所有等待的线程。
  4. 被唤醒的线程会重新获取锁，并再次检查条件（防止**虚假唤醒 Spurious Wakeup**），如果满足则继续执行。
- **用途**：常用于实现**生产者-消费者模型**、线程池的任务队列等。

#### 35. 什么是原子操作 (`std::atomic`)？

原子操作是指**不可被中断的操作，即在多线程环境下，一个原子操作要么完全执行，要么完全不执行，不会被中断或打断**。

- **`std::atomic`**：是 C++11 提供的一个类模板，用于封装一个值，并保证对这个值的所有操作都是原子的。
- 与互斥锁的对比：
  - **锁 (Mutex)**：是一种**阻塞**同步机制，保护的是一个**代码块**。开销较大。
  - **原子操作 (Atomic)**：是一种**非阻塞**同步机制（通常通过特殊的CPU指令实现），保护的是**单个变量**的访问。开销非常小。
- **用途**：适用于实现一些高性能的无锁数据结构，或简单的计数器、标志位等场景。

------

### 编程范式与综合设计

#### 36. 什么是 C++ 中的“零成本抽象”？

这是 C++ 设计哲学的一个核心原则，意为：**“你不需要为你没有使用的东西付出代价，而你所使用的东西，你也无法用更高效的手写代码来替代它。”**

- 例子：
  1. **模板**：如果你不使用模板，它不会产生任何代码。如果你使用它（如 `std::vector`），编译器会生成高度优化的、类型特定的代码，其性能与手写的 C 风格数组操作相当。
  2. **虚函数**：如果你不使用虚函数，你的对象就不会有 v-ptr，也不会有 v-table 的开销。
  3. **Lambda 表达式**：编译器通常能将其优化为高效的函数对象，性能几乎没有损失。
- **总结**：C++ 提供了大量高级的抽象工具，但这些工具被设计得非常高效，以至于它们在编译后产生的机器码与手动进行底层优化所产生的代码性能相差无几。

#### 37. 解释一下 C++ 的值类别？（左值、右值、纯右值、将亡值）

在 C++ 中，左值和右值是表达式的一种分类，它们主要根据表达式能否被寻址、能否被修改以及生命周期来区分。

**1. 左值 (lvalue):**

* **定义:** 左值是一个**可以取地址**的对象，它通常拥有一个标识符（如变量名），可以通过该标识符访问其值。
* **特征:**
  * **可寻址:** 可以使用取地址运算符 `&` 获取其内存地址。
  * **可修改:** 除非被 `const` 修饰，否则其值可以被修改。
  * **持久性:**  拥有持久性，其值在表达式结束后仍然存在。
* **例子:**
  * 变量名: `int x = 10;`  `x` 是左值。
  * 解引用指针: `int* p = &x; *p = 20;`  `*p` 是左值。
  * 数组元素: `int arr[5]; arr[2] = 5;`  `arr[2]` 是左值。
  * 返回左值引用的函数: `int& getVal() { return x; }`  `getVal()` 返回的是左值。

**2. 右值 (rvalue):**

* **定义:** 右值是一个**不能取地址**的对象（例如字面常量、算术表达式结果、临时对象等）。
* **特征:**
  * **不可寻址 (通常):** 通常情况下不能使用取地址运算符 `&` 获取其内存地址 (C++11 引入了右值引用，可以对某些右值取地址)。
  * **不可修改 (通常):** 通常情况下其值不能被修改 (C++11 引入了右值引用，可以修改某些右值)。
  * **短暂性:**  通常没有持久性，其值在表达式结束后可能会失效。
* **例子:**
  * 字面量: `10`, `"hello"`
  * 返回非引用类型的函数调用: `int foo() { return 10; }`  `foo()` 的返回值是右值。
  * 算术表达式结果: `x + y`, `a > b`
  * 临时对象：`std::string("world")`

**C++11 对右值的进一步分类:**

* **纯右值 (prvalue):**  例如字面量、临时对象等，它们的生命周期只在当前表达式内，不能被引用。
* **将亡值 (xvalue):**  表示一个**即将被移动资源**的对象，它虽然有名字（像左值），但已被标记为可以被“窃取”资源，生命周期即将结束，可以被右值引用延长生命周期并使用，从而触发移动语义。

**左值和右值的重要性:**

* **理解赋值操作:**  赋值操作的左侧必须是可修改的左值，右侧可以是左值或右值。
* **移动语义:**  C++11 引入的右值引用和移动语义可以利用将亡值，避免不必要的拷贝，提高程序效率。
* **函数参数传递:**  理解左值和右值有助于选择合适的参数传递方式 (值传递、引用传递、右值引用传递)。

### 编译、链接与程序结构

#### 38. C++ 程序从源码到可执行文件的过程是怎样的？

主要分为四个阶段：

1. 预处理 (Preprocessing)：处理以 `#` 开头的预处理指令。
   - `#include`：将头文件内容插入。
   - `#define`：进行宏替换。
   - `#if`/`#endif`：处理条件编译。
   - 生成 `.i` 或 `.ii` 文件。
2. 编译 (Compilation)：将预处理后的代码翻译成汇编代码。
   - 进行词法分析、语法分析、语义分析和优化。
   - 生成 `.s` 文件。
3. 汇编 (Assembly)：将汇编代码翻译成机器指令（二进制代码）。
   - 生成目标文件 (`.o` 或 `.obj` 文件)，包含了代码段、数据段等。
4. 链接 (Linking)：将多个目标文件和所需的库文件链接在一起，生成一个单一的可执行文件。
   - **符号解析**：将代码中引用的函数、变量名（符号）与其实际定义所在的地址关联起来。
   - **重定位**：修正代码中的地址，使其指向正确的运行时内存地址。

#### 39. `inline` 内联函数有什么作用？它和宏定义的区别是什么？

- 作用：`inline` 是对编译器的一个**建议**，希望它在调用点将函数体**展开**，而不是通过传统的函数调用机制（压栈、跳转）。

  - **优点**：省去了函数调用的开销，对于短小且频繁调用的函数能提升性能。
  - **缺点**：可能导致最终可执行文件体积增大。编译器有权忽略 `inline` 请求（如函数体过大、递归、虚函数等）。

- 与宏定义的区别：

  | 特性         | 内联函数 (`inline`)                | 宏定义 (`#define`)                                         |
  | :----------- | :--------------------------------- | :--------------------------------------------------------- |
  | **类型检查** | **有**，在编译时进行类型安全检查。 | **无**，在预处理阶段进行简单的纯文本替换，不安全。         |
  | **调试**     | **支持**，调试器可以按行调试。     | **不支持**，宏在预处理阶段就被替换了。                     |
  | **作用域**   | 受限于类或命名空间的作用域。       | 全局有效，容易造成命名污染。                               |
  | **副作用**   | 参数按值求值，无副作用。           | 参数被直接替换，可能导致意外的副作用（如 `MAX(a++, b)`）。 |
  | **适用场景** | 短小且频繁调用的函数               | 简单代码生成、条件编译（如 `#ifndef`）                     |

#### 40. 头文件中的 `ifndef`/`define`/`endif` 和 `#pragma once` 有什么作用和区别？

- **作用**：两者都是为了**防止头文件被重复包含**，避免因重复定义导致的编译错误。

- 区别：

  | 特性           | `ifndef`/`define`/`endif` (宏定义保护)                       | `#pragma once`(编译器指令保护)                               |
  | :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
  | **标准兼容性** | **C/C++ 标准**，所有编译器都支持，移植性最好。               | **非标准**，但被绝大多数现代编译器支持。                     |
  | **工作原理**   | 基于**宏定义**（逻辑标识）。编译器在处理文件时检查宏是否已被定义，根据特定条件选择性地编译代码片段。 | 基于**文件路径**（物理标识）。编译器记录文件位置，根据文件实际物理位置选择性编译代码片段，**编译速度可能更快**。 |
  | **健壮性**     | 需要确保宏名唯一，否则可能失效。                             | 不会受宏名冲突影响，更简单可靠。                             |

- **结论**：`#pragma once` 更简洁高效，但在需要保证最高可移植性的老旧项目中，宏定义保护仍然是首选。现代项目中两者混用或只用 `#pragma once` 很常见。

------

### 异常处理

#### 41. 什么是 C++ 的异常安全？

异常安全是指当程序发生异常时，代码仍然能够保持**正确的状态**，**不泄漏资源**，并且**系统处于一个一致、可用的状态**。
通常分为三个级别：

1. **基本保证 (Basic Guarantee)**：异常发生后，对象保持在一个**有效的、可析构**的状态，但状态可能已改变。**无资源泄漏**。这是最低要求。
2. **强保证 (Strong Guarantee)**：异常发生后，程序状态**回滚到操作开始之前的状态**。即“要么操作完全成功，要么就像什么都没发生过一样”。实现成本较高。
3. **不抛出保证 (Nothrow Guarantee)**：操作保证**永远不会抛出异常**。例如，`noexcept` 关键字标记的函数、基本类型的移动操作等。

#### 42. `noexcept` 关键字的作用是什么？

`noexcept` 是 C++11 引入的关键字，用于向编译器和调用者**承诺一个函数不会抛出异常**。

- 作用：
  1. **编译器优化**：如果编译器知道一个函数不会抛出异常，它就可以生成更高效的代码，因为它不需要在函数调用周围生成额外的异常处理（栈展开）代码。
  2. **移动语义**：对于标准库容器（如 `std::vector`），如果元素的**移动构造函数**被标记为 `noexcept`，容器在扩容时会优先使用**移动**而不是**拷贝**，因为移动是安全的（不会因异常导致数据丢失）。这能极大地提升性能。
- **注意**：如果一个 `noexcept` 函数实际上抛出了异常，程序会直接调用 `std::terminate` 终止运行，而不是进行栈展开。

------

### 高级设计与库

#### 43. 什么是委托构造函数 (Delegating Constructor)？

这是 C++11 引入的特性，允许一个构造函数**调用同一个类中的另一个构造函数**。

- **作用**：**减少代码重复**。如果多个构造函数有共同的初始化逻辑，可以将这个逻辑提取到一个主构造函数中，其他构造函数通过委托来调用它，然后再执行自己特有的初始化。

```
class MyClass {
private:
    int a, b, c;
public:
    MyClass(int val_a, int val_b, int val_c) : a(val_a), b(val_b), c(val_c) {}
    MyClass(int val_a, int val_b) : MyClass(val_a, val_b, 0) {} // 委托给三参数构造函数
    MyClass() : MyClass(0, 0, 0) {} // 委托给三参数构造函数
};
```

#### 44. `std::string` 和 C 风格字符串 (`char*`) 的区别？

- `std::string`：是 C++ 的一个**类**，提供了丰富的成员函数来操作字符串。
  - **内存管理**：**自动管理**内存，无需手动分配和释放。
  - **安全性**：自动处理边界检查，不易发生缓冲区溢出。
  - **功能**：提供了 `length()`, `find()`, `substr()`, `+` (拼接) 等大量便捷操作。
- C 风格字符串 (`char*`)：是一个指向以**空字符 `\0`** 结尾的字符数组的指针。
  - **内存管理**：需要**手动管理**内存 (`malloc`/`free` 或栈上数组)。
  - **安全性**：容易因忘记 `\0` 或数组越界导致**缓冲区溢出**等严重安全问题。
  - **功能**：操作依赖于 C 库函数（如 `strlen`, `strcpy`, `strcat`），使用不便且不安全。

































### 模板元编程与泛型编程

#### 45. 什么是类型萃取 (Type Traits)？

- **定义**：类型萃取是一系列**在编译期**查询和操作类型信息的模板技术。它允许我们根据类型的不同特性（如“是否为整数”、“是否为指针”、“是否可拷贝”等）来编写不同的代码逻辑。
- **实现**：通常通过**模板特化**来实现。定义一个通用的模板，再为需要特殊处理的类型提供特化的版本。
- **标准库支持**：C++11 在 `<type_traits>` 头文件中提供了丰富的类型萃取工具，如 `std::is_integral<T>`, `std::is_pointer<T>`, `std::is_base_of<Base, Derived>` 等。
- 用途：
  1. **编译期断言 (`static_assert`)**：确保模板参数满足特定要求。
  2. **标签分发 (Tag Dispatching)**：根据类型特性选择最优的算法实现。
  3. **SFINAE**：与 `std::enable_if` 结合，根据条件启用或禁用模板。

#### 46. 什么是 CRTP (Curiously Recurring Template Pattern)？

**CRTP (奇异递归模板模式)** 是一种 C++ 模板编程技巧，即**基类**的模板参数是其**派生类**本身。

- 形式：

  ```
  template <typename Derived>
  class Base {
      // ...
  };
  
  class Derived : public Base<Derived> {
      // ...
  };
  ```

- **核心作用**：在基类中，可以通过 `static_cast<Derived*>(this)` 安全地向下转型，从而调用派生类中定义的成员函数。

- 主要用途：

  1. **静态多态 (Static Polymorphism)**：实现多态行为，但没有虚函数带来的运行时开销（v-table）。所有函数调用在编译期就已确定。
  2. **代码复用**：为一组具有相似接口的类提供通用的实现，如实现通用的计数器、比较运算符等。

### 性能优化

#### 47. 什么是 RVO/NRVO (返回值优化/命名返回值优化)？

- **定义**：返回值优化 (Return Value Optimization) 是一种**编译器优化技术**，当函数返回一个**本地对象**时，编译器可以**省略**创建这个临时对象以及其后的拷贝/移动构造过程，直接在调用方的栈上构造最终的对象。
- **NRVO (Named RVO)** 是 RVO 的一种，特指对**有名字的**本地对象进行优化。
- **作用**：极大地减少了不必要的拷贝和移动开销，尤其是在函数返回大型对象（如 `std::vector`）时，能显著提升性能。
- **C++17 规定**：在某些情况下（如返回纯右值），返回值优化不再是可选的，而是**强制**的，这使得代码行为更加一致和可预测。

#### 48. 如何减少 `std::vector` 扩容时的性能开销？

`vector` 扩容时的内存重新分配和元素移动是其主要的性能瓶颈之一。

1. **使用 `reserve()`**：如果在创建 `vector` 时**预先知道**大概需要存储多少个元素，应立即调用 `reserve(n)` 来**一次性预分配足够的容量**。这可以完全避免后续所有因 `push_back` 导致的自动扩容。
2. **确保移动构造函数是 `noexcept`**：如前所述，如果 `vector` 中存储的元素类型有**移动构造函数**，并将其标记为 `noexcept`，那么 `vector` 在扩容时会使用**移动**而不是**拷贝**，效率会高得多。

### 并发与并行

#### 49. C++ 并发模型中，`std::async`, `std::thread`, `std::packaged_task` 有什么区别？

这些都是 C++ 用于启动异步任务的工具，但侧重点不同。

- **`std::thread`**：是最**底层**的线程抽象。它直接创建一个新的执行线程，并运行指定的函数。程序员需要**手动管理**线程的生命周期（`join()` 或 `detach()`），并且没有直接的方式来获取线程的返回值。
- **`std::packaged_task`**：是一个**更高层次**的抽象，它将一个**可调用对象**与一个 **`std::future`** 绑定在一起。它**不直接创建线程**，而是作为一个可以被移动和调用的任务对象。当它被调用时，其返回值或异常会被存入 `future` 中。常用于线程池的任务队列。
- `std::async`：是**最高层次**的抽象。它提供了一个非常简单的方式来**异步地运行一个函数**，并返回一个 `std::future` 来获取结果。
  - 启动策略：`std::async` 允许指定启动策略：
    - `std::launch::async`：保证在新线程中立即执行。
    - `std::launch::deferred`：延迟执行，直到在 `future` 上调用 `get()` 或 `wait()` 时才在当前线程执行。
    - 默认策略由实现决定，可能并发也可能延迟。
  - **优点**：简化了线程管理，自动处理线程创建和销毁，是启动“一次性”异步任务的首选。

#### 50. 什么是 C++ 内存模型？它解决了什么问题？

- **定义**：C++ 内存模型是一套**精确的规则**，它定义了**多线程环境下，对内存的读写操作如何表现**，以及一个线程的写操作何时对另一个线程可见。
- 解决了什么问题：在 C++11 之前，C++ 语言标准中**没有线程的概念**，多线程编程依赖于特定平台的库（如 pthreads, Windows API）。这导致了两个主要问题：
  1. **编译器和处理器的乱序执行 (Reordering)**：为了优化，编译器和CPU可能会重新排序指令，这在单线程中没问题，但在多线程中可能破坏程序的逻辑。
  2. **数据竞争 (Data Race)**：当两个或多个线程同时访问同一个非原子内存位置，且至少有一个是写操作时，会产生未定义行为。
- C++11 内存模型的核心：
  1. 引入了 **`std::atomic`** 和相关的原子操作，提供了跨平台的、无数据竞争的内存访问方式。
  2. 定义了 **Happens-before** 关系和**内存序 (Memory Order)** (`std::memory_order_...`)，允许程序员精确地控制编译器和CPU的优化行为，在保证正确性的前提下，尽可能地压榨性能。



这套总结基本涵盖了从 C++ 基础、STL、OOP 到并发、性能优化和底层原理的各个方面，能够全面地考察一个 C++ 开发者的技术水平。



















### 补充问题

#### 1. 迭代器和指针的区别？

指针是 C++ 的底层概念，**直接指向内存地址**；

而迭代器是 STL 的高层概念，是**访问容器内元素的一种统一、抽象的接口**。（可以把迭代器看作是一种“智能指针”或“泛型指针”。）

1. **抽象层次不同**：
   - **指针**：直接指向内存地址，是底层的、低级的。
   - **迭代器**：是一个更高层的抽象。它隐藏了容器底层的存储细节（数组、链表、红黑树等），只暴露统一的访问接口。
2. **设计目的与关联性不同**：
   - **指针**是泛用的，可以指向任何内存地址（变量、数组、函数等），与特定容器无关。
   - **迭代器**与特定容器类型绑定，其唯一目的是为了遍历和操作容器内的元素。例如，`vector`的迭代器和`list`的迭代器是不同的类型，行为也不同（前者是随机访问，后者是双向访问）。
3. **安全性和通用性不同**：
   - **指针**可以指向任何内存地址，可能越界，是不安全的。
   - **迭代器**的操作被重载，行为由容器自身定义（如`list`的`++`是跳转到下一节点）。它通过`begin()`和`end()`成员函数提供明确的、安全的遍历范围。

**一句话总结：** 指针是操作内存地址的“裸工具”，而迭代器是封装了访问逻辑、为遍历各种STL容器而设计的“安全工具”。

#### 2. 引用传递和值传递的区别？

- **引用传递（`&`）**：在 C++ 中，引用是原始对象的别名，**对形参所做的任何修改都会直接影响到调用函数时传入的那个实参**；使用引用传递可以避免不必要的拷贝，尤其是在递归中传递较大的对象（如 `vector`）时非常重要。

- **值传递**：当按值传递一个参数时，函数会创建这个参数的副本。形参传入的是编译器将参数值新拷贝的一个临时变量，即一个副本，对该副本的修改不会影响到原始对象。（作用范围仅限于函数内部：因为形参是副本，所以任何对它的修改都只会影响这个副本，而不会影响到调用函数时传入的实参。）函数结束后，这个副本会被销毁，修改也随之消失。

#### 3. C和C++的区别是什么？

C和C++最核心的区别在于**编程范式**和**语言特性**的极大扩展。

1. **编程范式不同**：
   - **C**是**过程式编程语言**，注重函数和数据结构。
   - **C++**是**多范式编程语言**，它在C的基础上，最重要地增加了**面向对象编程（OOP）和泛型编程**。
2. **核心特性差异**：
   - **面向对象 (OOP)**：C++引入了`class`（类）的概念，支持**封装、继承、多态**，这是与C最根本的区别。
   - **泛型编程**：C++提供了**模板（template）机制**，核心思想是**编写与具体数据类型无关的通用代码**，其直接产物就是强大的标准模板库（STL），包括各种容器、算法和迭代器。
   - **内存管理**：C使用`malloc/free`函数，而C++使用`new/delete`操作符，后者能自动调用对象的**构造函数和析构函数**，是类型安全的。
   - **新增关键特性**：C++增加了许多重要特性，如**引用（&）**、**函数重载**、**运算符重载**、**命名空间（namespace）**和**异常处理（try/catch）**等。

#### 4.介绍一下内存泄漏和悬空指针？

**1.内存泄漏 (Memory Leak)**

**定义:** **程序员在堆上动态申请了内存后，未及时释放已分配的内存空间，丢失了指向这块内存的指针，导致这块内存无法被系统回收。**

**根本原因**：忘记调用 `delete` 或 `free`。

**后果**：程序占用的内存会随着时间推移不断增长，最终可能耗尽系统资源，导致性能下降或程序崩溃。

**2.悬空指针 (Dangling Pointer)**

**定义:** **一个指针指向的内存已经被释放或者重新分配给其他对象，当试图通过这个指针去访问内存时,就会出现不可预知的行为。**

**根本原因**：内存被 `delete` 或 `free` 后，没有将对应的指针设置为 `nullptr`。

**后果**：通过悬空指针去访问或修改内存是**未定义行为 (Undefined Behavior)**，可能导致程序崩溃，数据毁坏。

**如何避免内存泄漏和悬空指针:**

* 使用智能指针 (smart pointers) 自动管理内存。
* 释放内存后将指针置空。
* 使用 RAII 技术，将资源的获取和释放绑定在一起。

#### 5. 进程和线程的区别？

**进程是操作系统资源分配的基本单位，拥有独立的地址空间；而线程是 CPU 调度的基本单位，共享进程的地址空间。**

可以把进程理解为一个**正在运行的程序实例**，而线程是这个程序内部的**一条执行路径**。

| 特性     | 进程 (Process)                                             | 线程 (Thread)                                                |
| :------- | :--------------------------------------------------------- | :----------------------------------------------------------- |
| 定义     | 资源分配的基本单位。一个正在执行的程序的实例。             | CPU调度的基本单位。进程内的一条执行路径。                    |
| 资源拥有 | 拥有独立的地址空间、内存、文件句柄等系统资源。             | 共享所属进程的地址空间和资源（如内存、文件），但有自己独立的栈、程序计数器和寄存器。 |
| 独立性   | 进程间相互独立，一个进程的崩溃通常不会影响其他进程。       | 同一进程内的线程共享资源，一个线程的崩溃可能会导致整个进程崩溃。 |
| 开销     | 创建、销毁和切换的开销较大，因为涉及独立的地址空间和资源。 | 创建、销毁和切换的开销较小，因为共享大部分资源。             |
| 通信     | 进程间通信（IPC）相对复杂，需要内核介入。                  | 线程间通信更简单，可以直接读写共享内存（需要同步机制）。     |

#### 6. 介绍一下用户态和内核态？

用户态和内核态是为了保护系统安全而设计的**两种 CPU 运行级别**。它们的核心区别在于**权限等级**：

- **内核态 (Kernel Mode)**：拥有系统的**最高权限**，可以执行任何 CPU 指令，直接访问所有内存和硬件设备。操作系统的内核就运行在这个状态。
- **用户态 (User Mode)**：权限**受到严格限制**。只能访问用户空间内存，无法直接访问硬件设备。应用程序运行在这个状态。

**为什么需要区分？**

这种隔离机制是操作系统的安全基石。它能**防止单个应用程序的错误（如非法内存访问）导致整个操作系统崩溃**，保证了系统的稳定性和安全性。

**如何切换？**

程序在用户态和内核态之间的切换是必然且频繁的。从用户态进入内核态主要通过三种方式：

1. **系统调用 (System Call)**：这是最主要的方式。比如，当程序要读写文件、创建进程或请求网络数据时，它必须发起系统调用，让内核来代为完成。
2. **异常 (Exception)**：当程序执行中发生错误，如除零错误、内存缺页等，会触发切换到内核态，由内核来处理这个异常。
3. **中断 (Interrupt)**：当外部设备（如键盘、鼠标、网卡）完成操作后，会向 CPU 发送中断信号，CPU 会立即切换到内核态来响应这个中断。

#### 7. nlohmann

**nlohmann库是一个C++ JSON库，用于处理JSON数据的解析、序列化、查询、遍历等操作。它是一个轻量级的库，易于使用和集成到C++项目中。**

nlohmann库在C++中处理JSON数据的**优势**主要有以下几点：
标准兼容性：nlohmann库完全符合C++11标准，支持所有标准C++11容器，并且可以与现有的C++代码无缝集成。
跨平台性：nlohmann库可以在多种平台上使用，包括Windows、Linux、macOS等。
可扩展性：nlohmann库可以轻松地扩展到其他JSON数据处理库中，例如使用第三方序列化器和反序列化器等。

#### 8. 虚拟地址是如何转换为物理地址的？页表的构成？MMU 了解过吗？

（1）虚拟地址转换为物理地址的过程由CPU中的**MMU（内存管理单元）硬件自动完成，核心思想是页表映射**。

1. **拆分虚拟地址**：CPU发出的虚拟地址被内存管理单元拆分为 **虚拟页号 和 页内偏移**。
2. **查询TLB（快表）**：MMU首先在TLB（页表的高速缓存）中查找虚拟页号，命中则直接获取**物理页号 **，速度极快；未命中则查询页表并更新TLB。
3. **查询页表**：MMU 用虚拟页号作为索引在页表中找到对应的**页表项**，从中取出**物理页号** 。
4. **拼接物理地址**：MMU 将获取到的**物理页号 ** 和原始的**页内偏移** 拼接起来，形成最终的物理地址。
5. **缺页中断**：如果在查询页表时，发现页表中的有效位为0，表示该页不在物理内存中，MMU会触发一个缺页中断，交由操作系统内核处理。

（2）页表是操作系统为每个进程维护的数据结构，**用于记录虚拟页到物理页的映射关系**。

- **本质**：一个**数组**，其索引是**虚拟页号 (VPN)**。
- **内容**：数组的每个元素是一个**页表项 (Page Table Entry, PTE)**。
- 页表项 (PTE) 包含的核心信息：
  - **物理页号 **：记录了对应的物理内存块。
  - **有效位**：标记该页是否在物理内存中。`1`表示在，`0`表示不在（可能在磁盘上），会触发缺页中断。
  - **权限位**：控制对该页的访问权限，如读、写、执行。
  - **脏位**：标记该页在加载入内存后是否被修改过。如果为`1`，在换出时需要写回磁盘。
  - **访问位**：标记该页是否被访问过，用于页面置换算法（如LRU）。

为了节省空间，现代操作系统通常使用**多级页表**（如x86-64的四级页表）。

注意！！**页表初始化时会不会把所有虚拟内存都映射到物理内存?**

页表初始化时，只会**建立虚拟地址空间到物理内存的映射框架**，并不会一次性把所有虚拟内存都映射到物理内存；**物理内存按需分配，通过缺页异常机制动态建立映射关系**。

（3）**MMU (内存管理单元)** 是连接CPU和物理内存的桥梁，专门负责处理CPU的内存访问请求。

- 核心功能：
  1. **地址转换**：自动将程序的虚拟地址转换为物理地址。
  2. **内存保护**：根据页表中设置的权限位，检查每一次内存访问的合法性（如防止用户代码写入内核空间、防止只读数据被修改等）。如果访问非法，MMU会触发一个硬件异常（如段错误），交由操作系统处理。
  3. **管理缓存（TLB）**：控制TLB的读写和刷新。

#### 9. 设计模式的原则？

1. **S - 单一职责原则 (Single Responsibility Principle)**
   - **核心**：一个类应该只有一个引起它变化的原因。
   - **解读**：一个类只做一件相关的事情。这使得类更简单、更健壮，且易于修改。
2. **O - 开放/封闭原则 (Open/Closed Principle)**
   - **核心**：软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。
   - **解读**：添加新功能时，应该通过增加新代码（如实现新子类）来完成，而不是修改现有已通过测试的代码。多态是实现这一点的关键。
3. **L - 里氏替换原则 (Liskov Substitution Principle)**
   - **核心**：子类型必须能够替换掉它们的基类型，而不破坏程序的正确性。
   - **解读**：派生类应该完全实现基类的“契约”（方法、行为）。简单说，任何使用基类指针/引用的地方，换成派生类对象后，程序行为不应出现异常。
4. **I - 接口隔离原则 (Interface Segregation Principle)**
   - **核心**：客户端不应该被强迫依赖于它们不使用的方法。
   - **解读**：使用多个小的、专一的接口，而不是一个大的、臃肿的“胖”接口。这避免了类实现它根本不需要的方法。
5. **D - 依赖倒置原则 (Dependency Inversion Principle)**
   - **核心**：高层模块不应依赖于低层模块，两者都应依赖于抽象；抽象不应依赖于细节，细节应依赖于抽象。
   - **解读**：要面向接口编程，而不是面向实现编程。通过依赖注入（DI）等方式，让代码依赖于抽象接口（如 `ILogger`），而不是具体的类（如 `FileLogger`），从而实现解耦。

#### 10.单例设计模式怎么实现？

单例模式的核心是**保证一个类只有一个实例，并提供一个全局访问点**。实现这一目标的关键在于：

1. **构造函数私有化**：防止外部通过 `new` 或在栈上创建实例。
2. **禁用拷贝和移动**：防止通过拷贝或移动构造/赋值产生新的实例。
3. **提供静态访问方法**：通过一个公共的静态方法（如 `GetInstance()`）来获取唯一的实例。

```
class Singleton {
public:
    // 3. 提供静态的全局访问点
    static Singleton& GetInstance() {
        // C++11 保证函数内的静态局部变量的初始化是线程安全的
        static Singleton instance; 
        return instance;
    }

    // 2. 删除拷贝和移动构造/赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    Singleton(Singleton&&) = delete;
    Singleton& operator=(Singleton&&) = delete;

private:
    // 1. 构造函数私有化
    Singleton() { /* ... 初始化 ... */ }
    ~Singleton() { /* ... 清理 ... */ }
};
```

#### 11. 观察者模式的应用场景?

观察者模式的核心是**实现对象间的解耦**，特别是当一个对象（“发布者”或“主题”）的状态变化需要通知一组其他对象（“订阅者”或“观察者”）时，而发布者又不希望与订阅者产生紧密耦合。

应用场景：

1. **一对多的依赖关系**：一个对象的状态变更需要触发多个其他对象的更新。
2. **广播通信**：一个事件或消息需要被广播给系统中不确定的、动态变化的一组对象。
3. **解耦事件源与事件处理者**：你希望一个对象（事件源）在不了解其“听众”具体身份和数量的情况下，能有效地通知它们。

#### 12. 工厂模式的分类及作用?

**工厂模式分类**

1. **简单工厂（Simple Factory）**：一个工厂类根据参数返回不同产品对象。
2. **工厂方法（Factory Method）**：将工厂抽象化，每个具体工厂负责创建一种具体产品。
3. **抽象工厂（Abstract Factory）**：提供一个接口，用于创建一组相关或依赖的产品对象。

**作用**

- **解耦**：将对象的创建与使用分离。
- **可扩展**：新增产品时，只需扩展工厂类，避免修改调用代码。
- **统一管理**：集中控制实例化逻辑，便于维护。

一句话总结：**工厂模式通过“工厂类”统一封装对象创建，提升代码解耦性和可扩展性。**

#### 13. `push_back` vs `emplace_back` 的核心区别

1. **构造方式**

   - **`push_back`**：接受**已构造好的对象**，再拷贝或移动到容器中，需要先创建对象。
   - **`emplace_back`**：直接在容器内存中**原地构造对象**（通过参数转发调用构造函数），避免了额外的拷贝或移动操作。

2. **性能差异**

   - **`emplace_back` 更高效**：尤其对复杂对象（如 `std::string`、`std::vector` 或自定义类），省去临时对象的构造和拷贝/移动开销。
   - **`push_back` 可能触发额外拷贝/移动**：若传入右值（如 `push_back(std::string("tmp"))`），会先构造临时对象，再移动到容器。

3. **代码示例**

   ```cpp
   std::vector<std::string> v;
   v.push_back("hello");      // 临时 string 构造 + 移动
   v.emplace_back("world");   // 直接调用 string(const char*) 构造函数，无临时对象
   ```

#### 14. ` shared_ptr` 的控制块设计是怎样的？`shared_ptr` 的引用计数存储在哪里？

（1）控制块设计：

控制块是一个**独立的堆上对象**，包含：

1. **强引用计数**（strong_count）：记录shared_ptr数量
2. **弱引用计数**（weak_count）：记录weak_ptr数量 + 1
3. **删除器**（deleter）：如果提供了自定义删除器，存储在这里。
4. **分配器**（allocator）：如果提供了自定义分配器，也存储在这里。

（2）引用计数存储位置：

**引用计数存储在独立的控制块中**，而非shared_ptr对象内部；多个shared_ptr通过指针共享这个控制块。

```
// shared_ptr内部结构
template<typename T>
class shared_ptr {
    T* ptr;              // 指向被管理对象
    ControlBlock* ctrl;  // 指向控制块（引用计数在这里）
};

// 控制块结构
struct ControlBlock {
    std::atomic<long> strong_count;  // 引用计数（原子类型）
    std::atomic<long> weak_count;    
    // ...
};
```

（3）两种内存布局：

```
// 1. new T：两次堆内存分配
（一次为所管理的对象分配内存，一次在 shared_ptr 构造函数内部，为“控制块”分配内存。
这两次分配不仅有额外的性能开销，还可能导致对象和其控制块在内存中位置不相邻，降低缓存命中率。）

shared_ptr<T>(new T)
    [shared_ptr] → [对象T]
         ↓
    [控制块]

// 2. make_shared：一次分配（对象和控制块连续）
（这里只会发生一次堆内存分配。make_shared 会一次性分配一块足够大的内存，同时容纳 所管理对象 和控制块。
优点：减少了堆分配的开销；对象和控制块在内存中是连续的，提高了缓存命中率，访问速度更快。）

make_shared<T>()
    [shared_ptr] → [控制块|对象T]
```

（3）三种位置区分：

```
shared_ptr<T> sp = make_shared<T>();

1. shared_ptr对象本身（包含两个指针）：看声明位置
   - 栈上/堆上/全局区等
   - 大小固定：通常16字节（64位系统）
   
2. 被管理对象T：始终在堆上
   - new T：单独的堆内存
   - make_shared：与控制块一起分配
   
3. 控制块：始终在堆上
   - 存储引用计数等信息
```

#### 15. 进程初始化时操作系统做了什么?

进程初始化时，操作系统主要做：

1. **创建进程控制块 PCB**：保存进程ID、寄存器、状态等控制信息。
2. **建立虚拟地址空间**：映射代码段、数据段、堆、栈等。
3. **加载程序**：把可执行文件映射/装载到内存。
4. **初始化运行环境**：设置栈指针、入口地址，传递参数和环境变量。
5. **分配基础资源**：如文件描述符、信号表。
6. **放入就绪队列**：等待调度运行。

总结：**操作系统为进程建立控制块、准备虚拟内存和运行环境，并将其挂到调度队列中等待执行。**

#### 16. 父类和子类有同名同参的函数，加 `virtua` 和不加有啥区别?

1. 不加 `virtual`（编译期绑定，静态绑定）

​	子类同名同参函数会**隐藏**父类函数。通过父类指针/引用调用时，执行的是**父类版本**，**调用哪个函数由指针或引用本身的类型决定，而不是由它实际指向的对象类型决定**。

**函数隐藏**：即使不加 `virtual`，子类的定义依然会覆盖名字查找结果，所以在子类对象上调用该函数时，优先匹配子类版本，父类同名函数不可见。

2. 加 `virtual`（运行期绑定，动态绑定）

​	子类函数会**重写**父类虚函数，实现多态。通过父类指针/引用调用时，执行的是**子类版本**，**调用哪个函数由指针所指向对象的实际类型在运行时决定**。

```
class Base {
public:
    void func(int x) { /*...*/ }
};

class Derived : public Base {
public:
    void func(int x) {
        Base::func(x);  // 调用父类版本
        // 子类自己的逻辑
    }
};
```

#### 17. 在派生类中，怎么调用基类那个同名同参的方法?

使用**作用域解析运算符 `::`** 来显式指定调用父类的版本。

- 在派生类中，同名同参的函数会**隐藏 **或 **重写**父类的版本。
- 因此，在 `Derived` 类的成员函数中如果直接调用 `print()`，它会默认调用 `Derived` 自己的版本，从而导致无限递归。

#### 18. 类里面为啥要有`static`函数?有啥用?一般用在什么地方?

类里面的 `static` 成员函数是一个**属于类本身，而不属于任何特定对象实例**的函数。

它的核心用途是执行那些**与类相关，但不需要依赖任何对象状态**的操作，实现工厂模式、单例模式等设计模式。

#### 19. `malloc`出来的指针，用`delete`会怎么样?

**用 `delete` 释放 `malloc` 的内存是严重的“未定义行为”，因为它会错误地尝试调用不存在的析构函数并可能因内存管理机制不匹配而破坏堆，导致程序崩溃或数据损坏。**

`delete` 会尝试为对象调用其析构函数。而 `malloc` 分配的只是一块**原始、未初始化的内存**，上面根本没有一个被正确构造的 C++ 对象。在这块原始内存上调用析构函数，其行为是不可预测的。

#### 20. 一个 Linux 程序一直跑，内存越用越少，可能是什么原因?如果内存占满了会怎么样?

**内存越用越少的可能原因：**

1. **内存泄漏** - 动态分配的内存没有正确释放。
2. **内存碎片** - 频繁申请释放不同大小内存块导致碎片化。
3. **缓存/缓冲区增长** - 程序设计上的缓存策略导致数据持续累积。
4. **容器无限增长** - vector、map等STL容器在持续地添加新元素，没有相应的移除或清理机制。

**内存占满后的后果：**

1. **OOM Killer触发** - Linux内核的OOM（Out of Memory）机制会强制终止进程。
2. **系统卡顿** - 内存占满会导致系统因磁盘交换而变得极度缓慢，性能急剧下降。
3. **进程分配内存失败** - 返回NULL或抛出std::bad_alloc异常。
4. **程序崩溃** - 如果没有正确处理内存分配失败，程序会异常终止。

**一句话总结：内存占满会导致系统因磁盘交换而变得极度缓慢，然后程序因无法分配新内存而崩溃，如果情况继续恶化，操作系统会为了自保而强制杀死消耗内存最多的进程。**

#### 21. 程序是自己崩的吗?具体会发生啥?

- **程序不会“自己崩溃”**，程序崩溃通常是因为出现了**未定义行为**或**运行时错误**：
  1. **非法内存访问**（野指针、数组越界、空指针解引用） → 触发段错误（SIGSEGV）。
  2. **除零、非法指令** → 触发 SIGFPE、SIGILL。
  3. **资源耗尽**（内存分配失败、栈溢出） → 抛异常或被系统终止。
  4. **逻辑错误** → 程序主动调用 `abort()`、`assert` 失败等。
- **具体表现**：
  - 操作系统向进程发送信号（如 SIGSEGV、SIGABRT）。
  - 进程被终止，可能生成 core dump 文件，方便调试。

总结：**程序崩溃通常是因非法操作触发系统信号，最终被操作系统强制终止。**

#### 22. `malloc`一个指针，然后改了它的指向，会发生什么?

- `malloc` 分配了一块堆内存，并返回指针指向该内存。
- 如果之后把指针改为指向别的地址：
  - **原来 `malloc` 的那块堆内存丢失引用**，操作系统无法再访问或释放造成**内存泄漏**。
  - 新指向的地址可能合法（比如别的变量），也可能非法（野指针）。

总结：修改 `malloc` 返回的指针，相当于丢失了对这块内存的引用，导致这块内存再也无法被访问或释放，从而造成了内存泄漏。

#### 23. 野指针会造成什么问题?

- **野指针的危害**
  - 指向未定义或不可访问的内存 → 读写会触发 **段错误 / 程序崩溃**。
  - 写入可能破坏其他数据 → **数据异常、产生难以调试的 bug**。
- **野指针 vs 悬空指针**
  - **野指针**：指一个**从未被有效初始化**的指针。它被创建时，其值是一个不确定的、随机的垃圾值。
  - **悬空指针**：指一个**曾经指向有效内存（原本合法），但这块内存已经被释放或失效**的指针。

总结：**野指针和悬空指针都会导致崩溃或数据破坏，区别在于一个“从未合法”，一个“曾经合法”。**

#### 24. 系统是怎么知道一个地址是否是有效的?

系统通过硬件**MMU（内存管理单元）**和**页表**机制来判断地址是否有效：

​	CPU 发出虚拟地址 → 交给 MMU，MMU 查 **TLB/页表**，如果虚拟页存在有效映射（有对应物理页、权限满足），则地址有效；否则触发缺页异常，表示地址无效。

#### 25. 虚拟地址映射里有个页表，这个页表是怎么找到的?

​	CPU 的**`CR3`寄存器**中保存当前进程的 **页表入口地址/页表基地址** ，操作系统进行进程切换时，会将新进程的页表基地址写入 CPU 的 `CR3` 寄存器；随后，MMU 硬件在每次进行地址翻译时，都会从寄存器指定的页表基地址找到页表，并开始逐级查表，最终找到对应的物理页。

#### 26. 静态链接和动态链接的区别？

- **静态链接**：编译时把库文件打包进可执行文件；运行时无需外部库，部署简单（优点）；最终生成的可执行文件体积大，库更新需要重新编译（缺点）。
- **动态链接**：程序运行时加载共享库；节省内存，升级方便，库更新无需重新编译（优点）；运行时依赖外部库环境（缺点）。

#### 27.  `make_shared`/`make_unique` 与直接使用 `new` 分配的区别？

`std::make_shared` 和 `std::make_unique` 是**工厂函数**，它们的作用是**以一种更安全、更高效的方式**来创建并初始化智能指针。

它们**封装了 `new` 表达式和智能指针的构造过程**，可以在一步操作内就得到一个指向新分配对象的智能指针。

`make_shared`/`make_unique`与直接使用`new`相比，主要有两大核心优势：**异常安全**和**性能更高**。

1. **异常安全**：`make_shared`和`make_unique`能避免在复杂表达式中因异常抛出而导致的内存泄漏。它们将内存分配和智能指针的构建绑定在一个函数调用中，保证了资源总能被正确接管。**而直接使用`new`，在内存分配后、智能指针构造前如果发生异常，会导致内存泄漏。**
2. **性能更高 (主要针对 `make_shared`)**：
   - 使用`new`创建`shared_ptr`需要**两次**堆内存分配：一次为所管理的对象分配内存，一次在 shared_ptr 构造函数内部，为“控制块”分配内存。这两次分配不仅有额外的性能开销，还可能导致对象和其控制块在内存中位置不相邻，降低缓存命中率。
   - 使用`make_shared`则只需要**一次**堆内存分配：分配一块足够大的内存，同时容纳`所管理对象和控制块`。减少了堆分配的开销，提高了缓存命中率，访问速度更快。）

####  28. C++11、14、17 的新特性

**C++11：是 C++ 历史上最重要的一次更新，它几乎重塑了整个语言**

**语言特性：**

1. **右值引用 (`&&`) 与移动语义 **
   - **解决的问题**：在 C++11 之前，临时对象（例如函数返回值）的传递会导致昂贵且不必要的深拷贝。一个从函数返回的 `std::vector` 会拷贝其所有元素。
   - **解决方案**：移动语义允许我们“窃取”临时对象（右值）的内部资源（如指向堆内存的指针），而非拷贝数据。`std::move` 就是一个信号，告诉编译器“这个对象的资源可以被安全地拿走”。这使得许多 O(N) 的拷贝操作变成了 O(1) 的移动操作。
2. **Lambda 表达式**
   - **解决的问题**：为 STL 算法编写小型的、局部的函数对象（仿函数）非常冗长和麻烦。
   - **解决方案**：提供了简洁的 `[捕获列表](参数){ 函数体 }` 语法，用于在代码中创建匿名函数。这极大地提高了 `std::sort`, `std::find_if` 等算法的可读性和易用性。
3. **`auto` 类型推导**
   - **解决的问题**：C++ 的类型，特别是涉及模板和迭代器时，可能变得极其冗长和繁琐（例如 `std::vector<MyClass>::const_iterator`）。
   - **解决方案**：编译器从变量的初始化表达式中自动推导出其类型。这使代码更简洁，不易出错，也更易于重构。
4. **基于范围的 `for` 循环 (Range-Based `for` Loop)**
   - **解决的问题**：传统的基于迭代器的 `for` 循环语法繁琐且容易出错。
   - **解决方案**：提供了一种非常简洁的语法 `for (auto& element : container)` 来遍历任何支持 `begin()` 和 `end()` 的容器。
5. **`nullptr`**
   - **解决的问题**：宏 `NULL` 本质上就是整数 `0`，这在函数重载时会导致歧义（例如 `foo(int)` vs `foo(char*)`）。
   - **解决方案**：引入了一个类型安全的关键字 `nullptr`，其类型为 `std::nullptr_t`，只能被转换为指针类型，从而消除了歧义。
6. **`override` 和 `final`**
   - **解决的问题**：因函数签名拼写错误而导致的虚函数重写（override）失败是一个常见且难以发现的bug。
   - **解决方案**：`override` 明确告诉编译器“这个函数意图重写基类的虚函数”，如果基类中没有可匹配的虚函数，编译器就会报错。`final` 则用于阻止派生类进一步重写某个虚函数，或阻止一个类被继承。
7. **强类型枚举 (`enum class`)**
   - **解决的问题**：C 风格的枚举会将其枚举名“泄露”到外围作用域，并且会隐式转换为整数，这都不是类型安全的。
   - **解决方案**：`enum class` 为其枚举名创建了独立的作用域（如 `Color::Red`），并且不会隐式转换为 `int`，使代码更安全、更具表达力。
8. **`constexpr` - 编译期表达式**
   - **解决的问题**：需要简单计算才能得出的常量，无法用于需要编译期常量的上下文（如数组大小）。
   - **解决方案**：`constexpr` 允许函数和变量在给定编译期输入的情况下，在编译期进行求值，模糊了运行时和编译期计算的界限，以获得性能提升。

**库特性：**

1. **智能指针 (`std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`)**
   - **解决的问题**：使用 `new` 和 `delete` 进行手动内存管理是 C++ bug 的头号来源（内存泄漏、重复释放、悬空指针）。
   - **解决方案**：提供了基于 RAII 的智能指针，自动管理动态内存的生命周期。`unique_ptr` 用于独占所有权，`shared_ptr` 用于共享所有权，`weak_ptr` 用于打破 `shared_ptr` 的循环引用。**这可以说是编写安全现代 C++ 最重要的特性。**
2. **标准化并发库 (`std::thread`, `std::mutex` 等)**
   - **解决的问题**：在 C++11 之前，多线程完全依赖于平台（如 pthreads, Windows threads）。
   - **解决方案**：提供了一个标准的、跨平台的库，用于创建和管理线程 (`std::thread`)、保护共享数据 (`std::mutex`, `std::lock_guard`)、同步线程 (`std::condition_variable`) 以及执行原子操作 (`std::atomic`)。
3. **`std::unordered_` 哈希容器**
   - **解决的问题**：`std::map` 和 `std::set` 是基于树的，提供 O(log N) 的查找效率。在许多场景下，需要更快的查找速度。
   - **解决方案**：提供了基于哈希表的容器 (`std::unordered_map`, `std::unordered_set`)，它们在插入、删除和查找操作上提供平均 O(1) 的时间复杂度。

------

**C++14：一次精炼的改进**

1. **泛型 Lambda (Generic Lambdas)**
   - **改进**：C++11 的 Lambda 需要为参数指定明确类型。C++14 允许使用 `auto` 作为参数类型，使 Lambda 成为一个模板：`[](auto a, auto b) { return a + b; }`。
2. **函数返回类型推导**
   - **改进**：`auto` 在 C++11 中可用于变量，但不能用于函数返回值。C++14 将此能力扩展，允许编译器从函数内部的 `return` 语句推导出返回类型。
3. **`std::make_unique`**
   - **改进**：C++11 提供了 `std::make_shared`，却遗漏了 `std::make_unique`。C++14 补上了这个“短板”，提供了创建 `unique_ptr` 的安全、高效的工厂函数。
4. **二进制字面量与数字分隔符**
   - **改进**：增加了编写数字字面量的便利性，例如 `0b11010110` 和 `long num = 1'000'000;`。

------

**C++17：一个强大的工具箱**

1. **`std::optional`**
   - **解决的问题**：一个函数可能返回一个值，也可能不返回。过去通常用返回指针（失败时返回 `nullptr`）或特殊的“魔术值”（如 `-1`）来表示，这很容易出错。
   - **解决方案**：提供了 `std::optional<T>` 包装器，以类型安全的方式明确表示一个可能存在或不存在的值。
2. **`std::variant` 和 `std::any`**
   - **解决的问题**：C 风格的 `union` 不是类型安全的，而 `void*` 更加不安全。
   - **解决方案**：`std::variant<T, U, ...>` 是一个类型安全的 `union`，它可以持有预定义类型集合中的一种。`std::any` 则可以持有任意单个类型的值。
3. **结构化绑定 (Structured Bindings)**
   - **解决的问题**：访问 `std::pair` 或 `std::tuple` 的元素很笨拙（`std::get<0>(t)`）。
   - **解决方案**：提供了一种简洁的语法，可以将元组、pair 或结构体的成员分解到独立的变量中：`auto [key, value] = myMap.begin();`。
4. **`if constexpr`**
   - **解决的问题**：编写模板代码时，常常需要根据类型的某些特性来执行不同的代码路径，这在过去需要复杂的 SFINAE 或标签分发技术。
   - **解决方案**：提供了一个编译期的 `if` 语句。基于 `constexpr` 条件不成立的分支会在编译期被完全丢弃，极大地简化了模板元编程。
5. **并行 STL 算法**
   - **解决的问题**：为常见的数据处理任务利用多核 CPU 需要手动编写线程代码。
   - **解决方案**：为许多 STL 算法重载了接受“执行策略”的版本（如 `std::execution::par`），使其能够自动并行执行。
6. **`std::filesystem`**
   - **解决的问题**：文件系统操作完全是非标准的、依赖于平台的。
   - **解决方案**：提供了一个标准的、跨平台的文件系统库，用于操作路径、文件和目录。
7. **`std::string_view`**
   - **解决的问题**：通过 `const std::string&` 传递字符串，对于字符串字面量或子串仍可能导致堆分配。通过 `const char*` 传递则会丢失长度信息。
   - **解决方案**：提供了一个轻量级的、不持有所有权的字符串视图。它提供了 `std::string` 的API，却没有内存所有权的开销，对于只读的字符串操作极为高效。

#### 29. 了解AVL树和红黑树吗？AVL树和红黑树的区别是什么

**红黑树(Red-Black Tree)概述：**

红黑树是一种自平衡二叉搜索树，它在每个节点上增加了一个颜色属性（红色或黑色），并通过遵循以下五条规则来确保树的平衡，从而保证了查找、插入和删除操作的最坏时间复杂度为`O(log N)`。

红黑树的五条性质：

- 节点颜色： 每个节点要么是红色，要么是黑色。
- 根节点： 根节点是黑色的。
- 叶节点： 所有叶节点（NIL节点，通常是虚拟节点）都是黑色的。
- 红色子节点： 如果一个节点是红色的，则它的两个子节点都是黑色的（即不能有两个连续的红色节点）。
- 黑色高度： 从任意节点到其所有叶子节点的所有路径都包含相同数量的黑色节点。

**AVL树(Adelson-Velsky and Landis Tree)概述：**

AVL树是最早被发明的自平衡二叉搜索树。它通过严格控制左右子树的高度差来保持平衡，确保任何节点的左右子树高度差的绝对值不超过1。这个高度差被称为平衡因子（Balance Factor）。

AVL树的平衡因子：

- 左子树高度 - 右子树高度
- 平衡因子只能是 -1, 0, 1。

AVL树的平衡调整： 当插入或删除节点导致平衡因子超出范围时，AVL树会通过四种基本旋转操作（LL、RR、LR、RL）来恢复平衡。

**AVL树和红黑树的区别：**

| 特性          | AVL树                                                        | 红黑树                                                       |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 平衡条件      | 任何节点的左右子树高度差的绝对值不超过1。                    | 通过颜色规则（红黑性质）来保持平衡。                         |
| 平衡严格性    | 严格平衡。对平衡的要求更严格。                               | 弱平衡。对平衡的要求相对宽松，允许一定程度的不平衡。         |
| 查找效率      | 更高。由于更严格的平衡，树的高度更小，查找路径更短。         | 略低于AVL树，但仍是`O(log N)`。                              |
| 插入/删除效率 | 较低。为了维持严格平衡，插入和删除操作可能需要更多的旋转和调整。 | 较高。相对宽松的平衡条件使得插入和删除操作所需的旋转和调整次数通常更少。 |
| 实现复杂度    | 相对复杂，需要维护每个节点的高度或平衡因子。                 | 相对复杂，需要维护每个节点的颜色，插入和删除的调整规则也较多。 |
| 应用场景      | 适用于查找操作远多于插入/删除操作的场景，如数据库索引。      | 适用于查找、插入、删除操作都比较频繁的场景，如`std::map`、`std::set`、Linux内核的进程调度等。 |

总结：

- AVL树追求更严格的平衡，因此在查找性能上略优，但插入和删除的开销可能更大。
- 红黑树追求操作的平均性能，在查找、插入和删除操作上都提供了稳定的`O(log N)`性能，且实现相对AVL树在工程上更易于接受，因此在实际应用中更为广泛。

#### 30. 快排和归并排序的过程？时间复杂度各是多少？最坏情况下会退化至多少？

**快速排序：**

过程：

1. 选择基准： 从待排序的数组中选择一个元素作为基准（pivot）。
2. 分区： 重新排列数组，将所有比基准值小的元素放到基准前面，所有比基准值大的元素放到基准后面（相等的元素可以放到任意一边）。在这个分区结束之后，该基准就处于数组的最终位置。
3. 递归排序： 递归地对基准前后的两个子数组进行快速排序。
4. 终止条件： 子数组的长度为0或1时，递归终止。

时间复杂度：

- 平均情况： `O(NlogN)`
- 最好情况： `O(NlogN)` (每次分区都将数组分成大致相等的两部分)
- 最坏情况： `O(N^2)`
- 最坏情况下退化： 当每次分区都产生一个空子数组和一个`N-1`长度的子数组时（例如，数组已经有序或逆序，并且每次都选择第一个或最后一个元素作为基准），快速排序会退化为`O(N^2)`。

**归并排序：**

过程：

1. 分解： 将待排序的数组从中间一分为二，得到两个子数组。
2. 递归排序： 递归地对这两个子数组进行归并排序，直到子数组只包含一个元素（一个元素被认为是自然有序的）。
3. 合并： 将两个已排序的子数组合并成一个更大的有序数组。

- 时间复杂度：
  - 平均情况： `O(NlogN)`
  - 最好情况： `O(NlogN)`
  - 最坏情况： `O(NlogN)`
- 最坏情况下退化： 归并排序在任何情况下都不会退化，其时间复杂度始终保持在`O(N log N)`。

**总结对比：**

| 特性         | 快速排序                               | 归并排序                                   |
| :----------- | :------------------------------------- | :----------------------------------------- |
| 思想         | 分治法，通过基准分区，递归排序子数组。 | 分治法，递归分解，然后合并已排序的子数组。 |
| 稳定性       | 不稳定 (相等元素的相对顺序可能改变)。  | 稳定 (相等元素的相对顺序保持不变)。        |
| 空间复杂度   | `O(log N)` (递归栈空间，最坏`O(N)`)。  | `O(N)` (需要额外的空间存储合并后的数组)。  |
| 时间复杂度   | 平均`O(N log N)`，最坏`O(N^2)`。       | 始终`O(N log N)`。                         |
| 是否原地排序 | 是 (大部分实现)。                      | 否 (需要额外空间)。                        |

#### 31. 哈希碰撞有几种解决方式？各自有什么优缺点？

**链法地址法：**

这是`std::unordered_map`等标准库最常用的实现方式。

- **原理**： 哈希表的每个位置（bucket）不是直接存储元素，而是一个指向数据结构（通常是**链表**，有时是红黑树）的指针。当发生碰撞时，所有哈希值相同的元素都被放入到同一个位置的链表中。
- **优点**：
  - **实现简单**：处理冲突的逻辑清晰，插入和删除操作直观。
  - **对负载因子容忍度高**：即使数据量超过哈希表大小（负载因子>1），仍然能正常工作，只是链表会变长，性能下降。
  - **删除操作方便**：直接从链表中删除节点即可。
- **缺点**：
  - **额外的内存开销**：需要存储指针，链表节点本身也有额外的指针开销。
  - **缓存不友好**：链表节点的内存地址通常不连续，遍历链表时容易导致CPU缓存未命中（Cache Miss），影响性能。

**开放地址法：**

所有元素都直接存储在哈希表数组中，不使用额外的数据结构。

- **原理**： 当要插入的位置已被占用时，按照某种规则去探测**下一个可用的空位**。根据探测规则的不同，又分为以下几种：

  a. **线性探测 (Linear Probing)**： 从当前位置开始，逐个检查下一个位置（`hash(key)+1`, `hash(key)+2`, ...），直到找到空位。

  - **优点**：实现简单，缓存友好性好（探测的是连续地址）。
  - **缺点**：容易产生“**一次聚集**”（Primary Clustering）现象，即冲突的元素会聚集在一起形成连续的区块，导致后续查找和插入的效率降低。

  b. **二次探测 (Quadratic Probing)**： 按二次方序列进行探测（`hash(key)+1²`, `hash(key)+2²`, ...）。

  - **优点**：有效缓解了线性探测的“一次聚集”问题。
  - **缺点**：会产生“**二次聚集**”（Secondary Clustering），即原始哈希值相同的键，它们的探测序列也完全相同。

- **共同优点**：
  - **无额外内存开销**：所有元素都在数组内，节约内存。
  - **缓存友好**：数据更集中，缓存命中率通常更高。
- **共同缺点**：
  - **对负载因子敏感**：当负载因子较高时（通常>0.7），性能会急剧下降，探测次数会显著增加。
  - **删除操作复杂**：不能简单地删除元素，因为会截断探测链。通常需要标记为“已删除”（墓碑标记，Tombstone），这会增加实现的复杂度和空间消耗。

3. 再哈希 (Rehashing)

这不算是直接的冲突解决方法，而是与哈希表性能密切相关的配套机制。当哈希表的负载因子超过某个阈值时，为了减少未来的碰撞，会创建一个更大的新哈希表（通常是原大小的2倍），然后遍历旧表中的所有元素，重新计算哈希值并插入到新表中。这是一个成本较高的操作，但可以保证哈希表在整体上维持较低的碰撞率和高效的性能。

**总结**

| 方法           | 优点                                   | 缺点                               | 适用场景                                                     |
| -------------- | -------------------------------------- | ---------------------------------- | ------------------------------------------------------------ |
| **拉链法**     | 实现简单、删除方便、对负载因子容忍度高 | 额外内存开销、缓存不友好           | 通用场景，特别是无法预估数据规模、写操作频繁的场景（如 `std::unordered_map`） |
| **开放地址法** | 节约内存、缓存友好                     | 实现复杂、删除麻烦、对负载因子敏感 | 数据量可预知、内存受限、读操作远多于写操作的场景             |

#### 32. 构造函数能是虚函数吗？析构函数能是虚函数吗？

**构造函数不能是虚函数**：

- 因为虚函数机制依赖对象的 **vptr（虚表指针）**，而虚表指针是在构造函数执行期间才建立的；
- 在构造函数执行完毕之前，对象的`vptr`（虚指针）还没有被正确设置，对象类型尚不完整。因此，**对象未完全构造好前无法进行虚函数分派**。

**析构函数可以（且常应）是虚函数**：

-  当通过基类指针`delete`一个派生类对象时，如果基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数。这会导致派生类中特有的资源（如动态分配的内存、文件句柄等）无法被释放，从而造成内存泄漏或其他资源泄漏。

#### 33. 常用的STL容器有什么？平时用过哪些容器，详细介绍一下？

STL容器是C++标准库的核心组成部分，提供了多种用于存储和组织数据的数据结构。它们可以分为几类：

- 序列容器：`vector` - 动态数组, `deque` - 双端队列, `list` - 双向链表, `array` - 固定数组, `forward_list` - 单向链表
- 关联容器：`set/multiset` - 有序集合, `map/multimap` - 有序键值对
- 无序关联容器：`unordered_set` - 哈希集合, `unordered_map` - 哈希表
- 容器适配器：`stack` - 栈, `queue` - 队列, `priority_queue` - 优先队列

在平时的项目中，我最常用的容器是`std::vector`、`std::unordered_map`和`std::string`（虽然`string`在技术上不是容器，但其行为非常相似）。下面详细介绍一下我经常使用的几个容器：

1. `std::vector`

- 底层数据结构：动态数组。它将元素存储在一段连续的内存空间中。
- 核心特性：
  - 随机访问：支持通过索引（`[]`或`.at()`）在O(1)时间内访问任意元素。
  - 动态扩容：当元素数量超过当前容量时，会自动分配一块更大的内存，并将原有元素移动或复制到新内存中。
  - 尾部插入/删除高效：在尾部添加（`push_back`）或删除（`pop_back`）元素通常是摊还O(1)时间复杂度。
  - 中间插入/删除低效：在数组中间或开头插入/删除元素需要移动后续所有元素，时间复杂度为O(n)。
- 使用场景：
  - 需要频繁进行随机访问的场景。
  - 元素数量不确定，但大部分操作是在尾部进行的场景。
  - 作为函数参数或返回值，传递一组数据。
  - 是大多数情况下的默认首选序列容器，因为其内存连续性对CPU缓存非常友好，性能通常最好。

1. `std::unordered_map`

- 底层数据结构：哈希表（Hash Table）。
- 核心特性：
  - 键值对存储：存储`<Key, Value>`形式的元素。
  - 快速查找、插入和删除：在平均情况下，这些操作的时间复杂度都是O(1)。在最坏情况下（所有元素哈希冲突），会退化到O(n)。
  - 无序：元素在容器中的存储顺序是不确定的，与插入顺序无关。
  - 键唯一：一个`unordered_map`中不能有重复的键。
- 使用场景：
  - 需要快速根据键查找值的场景，例如缓存、索引、字典等。
  - 对元素的顺序没有要求。
  - 当性能（特别是查找速度）是首要考虑因素时，通常优于`std::map`。

1. `std::map`

- 底层数据结构：红黑树（Red-Black Tree），一种自平衡的二叉搜索树。
- 核心特性：
  - 键值对存储：与`unordered_map`类似。
  - 有序：元素总是根据键自动排序。遍历`map`时，会得到一个有序的序列。
  - 查找、插入和删除稳定：所有这些操作的时间复杂度都是O(log n)。
  - 键唯一：与`unordered_map`相同。
- 使用场景：
  - 需要存储键值对，并且需要对键进行排序的场景。
  - 需要进行范围查找的场景（例如，查找所有键在某个范围内的元素），这是`unordered_map`无法高效完成的。
  - 当对性能有稳定要求，不希望出现哈希表最坏情况下的性能抖动时。

1. `std::list`

- 底层数据结构：双向链表。
- 核心特性：
  - 快速插入和删除：在链表的任何位置插入或删除元素都是O(1)时间复杂度（前提是已经有了指向该位置的迭代器）。
  - 不支持随机访问：访问第n个元素需要从头或尾开始遍历，时间复杂度为O(n)。
  - 迭代器稳定性：插入或删除元素不会导致其他元素的迭代器失效（除非删除的就是迭代器指向的那个元素）。
- 使用场景：
  - 需要频繁在容器中间进行插入和删除操作的场景。
  - 当迭代器稳定性至关重要时。
  - 在现代C++中，由于其缓存不友好性，`std::list`的使用场景已经越来越少，很多时候`std::vector`即使在中间插入删除，由于高效的移动语义和缓存性能，综合表现也可能更好。

#### 34. 构造函数里面可以使用this指针吗？

构造函数本质上是一个特殊的成员函数，所以在其函数体内，`this`指针已经可用，它指向正在被创建的对象实例。

但是，使用时必须非常小心，因为在构造函数执行期间，对象正处于**“未完全构造好”**的状态。

**安全且常见的使用场景：**

- **消除同名歧义**：当成员变量和函数参数同名时，使用`this->`来明确指定访问的是成员变量。这是最常见的用法。

  ```
  class MyClass {
  public:
      MyClass(int data) {
          this->data = data; // 必须使用 this-> 来区分
      }
  private:
      int data;
  };
  ```

- **返回对象引用以实现链式调用**：

  ```
  class MyBuilder {
  public:
      MyBuilder& setName(const std::string& name) {
          this->name = name;
          return *this; // 返回当前对象的引用
      }
  };
  ```

**存在风险的危险用法（面试重点）**

- **在构造函数中调用虚函数**： 在构造函数中通过`this`指针调用虚函数，**不会发生多态**。调用会被静态绑定到**当前类**的版本，而不是派生类的版本。
  - **原因**：在执行基类的构造函数时，派生类的部分还没有被构造，对象的动态类型被认为是基类类型，`vptr`指向的是基类的虚函数表。
- **将`this`指针传递给外部**： 在构造函数完成之前，不要将`this`指针泄露给其他的对象或函数（例如，在一个全局列表中注册`this`）。
  - **原因**：外部代码可能会通过这个指针去访问一个**尚未构造完成**的对象。如果它访问了还未初始化的成员（特别是派生类的成员），或调用了虚函数，会导致**未定义行为**。

​	**构造函数中可以使用`this`指针，但要牢记此刻`this`指向的是一个“半成品”。** 应该仅用它来访问当前类已初始化的成员，避免调用虚函数和将它传递给外部。

#### 35. 深拷贝和浅拷贝

**关键区别：** 浅拷贝共享资源，深拷贝独立拥有资源。

1. **浅拷贝**：
   - 只复制对象的**值**本身
   - 对于指针成员，只复制**指针地址**，不复制指针指向的内容
   - 结果：多个对象的指针指向**同一块内存**
   - ⚠️ 问题：析构时会造成**重复释放资源**，一个对象释放内存后，其他对象的指针变成悬空指针
2. **深拷贝**：
   - 复制对象的值，同时**递归复制指针指向的内容**
   - 为指针成员分配**新的内存**，复制数据
   - 结果：多个对象完全独立，互不影响

**示例：**

```cpp
class Shallow {
    int* ptr;
public:
    Shallow(int val) : ptr(new int(val)) {}
    
    // 浅拷贝（默认行为）
    Shallow(const Shallow& other) : ptr(other.ptr) {}  // 只复制指针
    
    ~Shallow() { delete ptr; }  // 危险！可能double free
};

class Deep {
    int* ptr;
public:
    Deep(int val) : ptr(new int(val)) {}
    
    // 深拷贝
    Deep(const Deep& other) : ptr(new int(*other.ptr)) {}  // 复制内容
    
    ~Deep() { delete ptr; }  // 安全
};

// 使用示例
Shallow s1(10);
Shallow s2 = s1;  // s1.ptr == s2.ptr，指向同一内存
// s1析构后，s2.ptr成为悬空指针！

Deep d1(10);
Deep d2 = d1;  // d1.ptr != d2.ptr，各自独立
// 安全，互不影响
```

#### 36. 介绍一下进程的通信方式有哪些？线程间的同步和互斥怎么解决？

**一、进程的通信方式有哪些？**

进程间通信（Inter-Process Communication, IPC）是为了让不同进程能够交换数据和信息。因为进程的地址空间是相互隔离的，所以需要操作系统提供机制来支持。常用的方式有：

1. **管道 (Pipe)**
   - **匿名管道**：半双工（单向通信），只能在具有**亲缘关系**（如父子）的进程间使用。它是一个内核缓冲区，一端写入，一端读出。
   - **命名管道 (FIFO)**：一种特殊的文件存在于文件系统中，允许**无亲缘关系**的进程间通信。
2. **共享内存 (Shared Memory)**
   - **最快的方式**。操作系统将一块物理内存映射到多个进程的虚拟地址空间中，进程可以像读写普通内存一样直接访问，无需内核介入。
   - **缺点**：不提供任何同步机制，必须配合**信号量**或**互斥锁**等同步原语来保证数据一致性。
3. **消息队列 (Message Queue)**
   - 存放在内核中的一个消息链表。它克服了管道只能传递无格式字节流和缓冲区大小有限的缺点。
   - 允许多个进程进行读写，通信方式更灵活，可以实现异步通信。
4. **信号量 (Semaphore)**
   - 它本质上是一个**计数器**，主要用于**进程/线程间的同步和互斥**，而不是传递复杂数据。常用来控制对共享资源的访问（如协调对共享内存的访问）。
5. **信号 (Signal)**
   - 一种异步通信机制，用于通知接收进程某个事件已经发生。它是唯一一种异步的通信方式，数据传递能力很弱（通常只传递一个信号编号）。
6. **套接字 (Socket)**
   - **最通用的方式**。它不仅可以用于同一台主机上的进程间通信，还可以用于**不同主机**之间通过网络的通信。

| 通信方式     | 速度 | 复杂度             | 数据量 | 适用范围                   |
| ------------ | ---- | ------------------ | ------ | -------------------------- |
| **共享内存** | 最快 | 复杂（需自行同步） | 大     | 同一主机                   |
| **管道**     | 较快 | 简单               | 有限   | 同一主机（匿名管道限亲缘） |
| **消息队列** | 中等 | 中等               | 有限   | 同一主机                   |
| **套接字**   | 较慢 | 复杂               | 大     | **任意主机（网络）**       |

**二、线程间的同步和互斥怎么解决？**

线程共享同一进程的地址空间，因此通信很方便，但也带来了数据竞争问题。解决同步和互斥主要依赖以下几种机制（在C++中，推荐使用标准库提供的工具）：

1. **互斥锁 (Mutex)**
   - **核心作用**：实现**互斥**，保证在任何时刻，只有一个线程可以访问被其保护的临界区代码或共享资源。
   - **C++实现**：`std::mutex`。为避免忘记解锁和处理异常，强烈推荐使用RAII风格的锁管理器，如 `std::lock_guard`（简单锁定/解锁）和 `std::unique_lock`（功能更强，可灵活解锁和配合条件变量）。
2. **条件变量 (Condition Variable)**
   - **核心作用**：实现**同步**，允许一个线程等待某个特定条件成立，而另一个线程在条件成立时可以通知（notify）等待的线程。
   - **特点**：它总是和**互斥锁**配合使用，以防止在检查条件和进入等待状态之间发生竞态条件。
   - **C++实现**：`std::condition_variable`。
3. **信号量 (Semaphore)**
   - **核心作用**：更广义的同步工具。它可以控制**同时访问某个资源的线程数量**。当计数值为1时，它就等价于一个互斥锁。
   - **场景**：适用于控制资源池的访问，比如一个有N个连接的数据库连接池。
   - **C++实现**：`std::counting_semaphore` (C++20)。
4. **原子操作 (Atomic Operations)**
   - **核心作用**：对一些简单类型（如整型、布尔型、指针）的读、写、修改操作提供**原子性**保证，即这些操作在执行过程中不会被其他线程中断。
   - **特点**：它是一种**无锁（lock-free）**的编程方式，比使用互斥锁开销更小，性能更高，但仅适用于简单的、单个变量的同步场景。
   - **C++实现**：`std::atomic<T>` 系列模板。

**总结**

- **互斥**（只让一个进）：首选 `std::mutex` + `std::lock_guard`。
- **同步**（需要等待通知）：使用 `std::condition_variable` + `std::unique_lock`。
- **简单计数/标志位**：使用 `std::atomic` 以获得更高性能。
- **控制资源数量**：使用 `std::counting_semaphore` (C++20)。

#### 37. 只有 2GB 物理内存，`new` 一个 4GB 对象，能实现吗？为什么？

​	通常情况下可以实现，涉及到**虚拟内存机制**：`new`操作首先分配的是虚拟地址空间，预留虚拟地址，不立即占用物理内存；只有当代码实际访问这块内存的某个部分（比如一个内存页）时，才会分配物理内存。当物理内存不足时，会通过一些页面置换算法，将不常用的数据换出到磁盘空间上，为新数据腾出位置，需要时再换入，从而实现虚拟内存大于物理内存。

​	尽管理论上可行，但实际运行时，**程序会因为频繁地在内存和磁盘之间交换数据而变得极其缓慢**，磁盘I/O将成为巨大的性能瓶颈，最终程序很可能触发OOM Killer被系统终止。

**实际情况：**

```cpp
char* p = new char[4GB];  // 成功，只分配虚拟地址

// 如果访问全部4GB数据
for(int i = 0; i < 4GB; i++) {
    p[i] = 1;  // 会触发页面置换，性能极差但可以运行
}
```

#### 38. 如何对Linux系统（例如Ubuntu）进行扩容？

为Linux系统扩容，其核心思路是**自底向上、逐层扩展**。从物理存储到文件系统，每一层都需要被告知空间变大了。

具体步骤取决于两大关键因素：**① 运行环境（虚拟机/物理机）** 和 **② 分区方案（LVM/标准分区）**。

目前最常见和推荐的方案是**在虚拟机环境下使用LVM（逻辑卷管理）**。

假设我们要扩容根目录所在的磁盘。**前提：始终先备份重要数据！**

**第1步：扩展物理/虚拟磁盘**

这是在操作系统**外部**完成的。

- **虚拟机 (VMware, VirtualBox)**：在虚拟机关机状态下，直接在设置中调大虚拟磁盘的容量（例如从50G调整到80G）。
- **云服务器 (AWS, GCP, Azure)**：在云平台的控制台中，在线调整云硬盘（EBS, Persistent Disk等）的大小。

**第2步：让系统识别新空间**

```
sudo fdisk -l           # 查看新空间
sudo fdisk /dev/sda     # 分区（或使用 parted/gdisk）
sudo partprobe          # 让系统识别新分区
```

**第3步：扩展分区**

我们需要让分区表占用新增加的未分配空间。

**推荐工具**：`growpart` (来自`cloud-utils-growpart`包，通常已安装)。它非常安全和方便。

```
语法: growpart [设备名] [分区号]
sudo growpart /dev/sda 3 
```

**第4步：扩展物理卷**

```
pvresize /dev/sda3
```

**第5步：扩展逻辑卷**

```
lvextend -L +10G /dev/mapper/ubuntu-root
```

**第6步：扩展文件系统**

- **对于ext4文件系统 (Ubuntu默认)**：

  ```
  对逻辑卷路径执行resize2fs
  sudo resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv
  ```

- **对于XFS文件系统 (CentOS默认)**：

  ```
  sudo xfs_growfs /
  ```

- 执行 `df -h` 检查，你会看到根目录 `/` 的空间已经成功扩展。



LVM（逻辑卷管理器）是Linux下的一种**磁盘分区管理机制**，在物理硬盘和文件系统之间增加了一个逻辑层。

```
文件系统
    ↓
LV (Logical Volume)     逻辑卷 - 最终使用的"分区"
    ↓
VG (Volume Group)       卷组 - 存储池
    ↓
PV (Physical Volume)    物理卷 - 实际硬盘/分区
    ↓
物理硬盘 (/dev/sda, /dev/sdb...)
```

| 传统分区           | LVM               |
| ------------------ | ----------------- |
| 大小固定，难以调整 | **动态扩容/缩减** |
| 受物理磁盘限制     | 可跨多个磁盘      |
| 不支持快照         | **支持快照备份**  |

```
查看LVM信息
pvdisplay  # 查看物理卷
vgdisplay  # 查看卷组
lvdisplay  # 查看逻辑卷

Ubuntu默认安装常见LVM路径
/dev/mapper/ubuntu-root
/dev/mapper/ubuntu-home
```

**形象比喻**

- **传统分区**：把硬盘切成固定的几块蛋糕
- **LVM**：把多个硬盘倒入一个"存储池"，需要多大就舀多大

#### 39. HTTP和HTTPS协议的区别

HTTP和HTTPS最核心的区别在于**安全性**。**HTTPS是HTTP的安全加密版本**。

这个“安全” (S) 是通过在HTTP协议和TCP/IP协议之间增加一层**SSL/TLS加密层**来实现的。这层加密层提供了三大核心安全保障：

1. **数据加密（机密性）**
   - **HTTP**：所有数据（包括URL、headers、body，如密码和信用卡号）都是**明文传输**的。网络上的任何中间节点（如路由器、ISP）都可以“窃听”和“偷窥”传输的内容。
   - **HTTPS**：通过SSL/TLS对所有传输的数据进行**对称加密**。即使数据被截获，窃听者也只能看到一堆无法破解的密文。
2. **身份认证（真实性）**
   - **HTTP**：客户端无法验证它正在通信的服务器是否真的是它声称的那台服务器。这使得“中间人攻击”成为可能，攻击者可以冒充服务器。
   - **HTTPS**：通过**SSL证书**（由受信任的CA机构颁发）来认证服务器的身份。浏览器会检查证书的有效性，确保用户访问的是真实、合法的网站，而不是一个伪造的钓鱼网站。
3. **数据完整性**
   - **HTTP**：无法保证数据在传输过程中没有被篡改。攻击者可以在数据包中注入恶意代码或修改内容，而客户端毫不知情。
   - **HTTPS**：SSL/TLS使用**消息认证码 (MAC)** 或数字签名来确保数据在传输后未被更改，保证了数据的完整性。

**总结对比表**

| **特性**     | **HTTP (超文本传输协议)** | **HTTPS (安全超文本传输协议)**                        |
| ------------ | ------------------------- | ----------------------------------------------------- |
| **核心**     | 明文传输 (Insecure)       | 加密传输 (Secure)                                     |
| **安全性**   | **无**                    | **有** (通过SSL/TLS提供加密、认证、完整性)            |
| **默认端口** | **80**                    | **443**                                               |
| **URL前缀**  | `http://`                 | `https://`                                            |
| **性能开销** | 开销小，速度快            | 存在SSL/TLS握手开销，建立连接稍慢（但现在已高度优化） |
| **证书**     | 不需要                    | **需要** (由CA颁发的SSL/TLS证书)                      |

**面试核心观点**：当面试官问到时，可以这样回答——“HTTPS就是在HTTP的基础上，增加了SSL/TLS层，它通过**加密**解决了窃听问题，通过**证书**解决了冒充问题，通过**完整性校验**解决了篡wygai问题。”

#### 40. appium测试框架

##### **核心原理**：

​	Appium框架是**基于客户端/服务器（C/S）的一种架构**。它的核心是一个用Node.js编写的**Appium Server**（服务器），这个服务器扮演一个“中间代理”的角色，**接收客户端的测试指令，并将其翻译成目标平台的原生指令**。它扩展了Selenium的**WebDriver协议**，使其能够支持移动端。当我们在客户端编写执行一个测试脚本时，它会向Appium Server发送一个标准的HTTP请求，Appium Server收到这个命令后，会根据我们启动会话时提供的平台信息，将这个标准命令“翻译”成对应平台的原生自动化框架能听懂的指令：对于Android，它会使用**UiAutomator2**框架；对于iOS，它会使用**XCUITest**框架。然后，它通过这些原生框架在设备上执行操作，并将执行结果返回给我们的测试脚本。

##### **测试步骤**：

启动Appium Server服务器后，它会监听一个端口（默认为4723）；

（1）**初始化**：在测试代码中，首先配置连接设备的参数信息，如`platformName`设置要连接的是哪个平台（Android还是iOS）、`deviceName`设备名称id、`appPackage`要启动的应用包名、`appActivity`要启动的应用UI界面。

（2）**定位元素**：Appium Server根据这些信息在指定设备上启动应用并建立会话，一旦会话成功创建，我们的`driver`对象就获得了控制权，接下来的使用`driver`对象来**定位元素**；Appium支持`ID`、`XPATH`、`Accessibility ID`等标准定位器；我一般使用`Inspector`来查找并定位，手机App中UI界面的元素；

（3）**执行操作并断言验证**：找到元素后，就可以执行**交互操作**，包括`Click()`（点击）和`Send_Keys()`（输入文本）等标准操作，此外Appium扩展了WebDriver协议，支持了移动端特有的**手势操作**，如`Swipe`（滑动）、`Tap`（按坐标轻点）等；在关键步骤执行后，我们会获取最终界面元素的文本或属性来进行**断言**，验证UI状态是否符合预期。

（4）**关闭Session**：当测试用例执行完毕，我们调用`driver->Quit()`方法，通知Appium Server终止会话，清理设备上的代理并关闭应用程序，从而完成一个完整的自动化测试闭环。

##### **常用adb命令：**

```
adb shell getprop ro.build.version.release					获取手机版本号
```

```
adb shell dumpsys window | findstr mCurrentFocus			获取手机当前启动的app和界面
```

##### appium客户端测试指令：

```
`EC.visibility_of_element_located` (等待“可见”)
```

检查元素在屏幕上是**可见的**， 当不需要点击，而是要 `.send_keys()` 或 `.get_text()` 这个元素，就应该使用 `EC.visibility_of_element_located`。

```
`EC.element_to_be_clickable` (等待“可点击”)
```

检查元素是 **`enabled` (可用)** 的，当需要 `.click()` 这个元素，就应该使用 `EC.element_to_be_clickable`。

##### 👨‍💻 自动化测试项目完整流程总结：

**阶段一：测试环境搭建** 

这是所有工作的基础，首先要搭建一套完整的 App 自动化测试环境，主要包括：

- **基础环境：** 安装 **Java SDK** (Android SDK 依赖) 和 **Android SDK** (提供 `adb` 等调试工具)。
- **核心服务：** 安装 **Appium Server** (v1.x GUI 或 v2.x 命令行)，作为自动化指令的中转站。
- **测试端：** 准备 Python 环境，并安装核心的第三方库，即 **`Appium-Python-Client`**。
- **执行设备：** 准备测试用的**真机**或**手机模拟器**，并确保 `adb` 可以成功连接。

**阶段二：线性脚本编写** 

在环境搭好后，进入初期的脚本编写阶段，也称为“线性脚本”或“脚本化”阶段。

- **1. 业务梳理：** 首先，梳理 App 的核心业务模块，例如：
  - 登录/注册
  - 浏览文章
  - 发布文章
  - 点赞、评论、收藏
- **2. 编写脚本：** 针对每个核心业务，我会创建独立的 `.py` 脚本文件（如 `toutiao_login.py`）。
- **3. 冒烟测试：** 我会编写包含正反例的自动化用例，执行第一轮“冒烟测试”，确保自动化流程可以跑通。
- **4. 添加断言：** 在关键步骤后加入断言（Assert），以保证自动化用例的准确性。

**阶段三：架构设计 - 引入 POM 模式**

线性脚本的维护性很差。为了让框架更健壮、可维护，我会引入**页面对象模型 (Page Object Model, POM)** 来进行封装。

- **1. 封装 (Encapsulation)：**
  - **页面类：** 我会为 App 的**每一个界面**（或一个独立的流程）创建一个专属的 Python 类（例如 `LoginPage.py`）。
  - **元素属性：** 将该界面上所有需要操作的元素（Element Locators），封装为这个类的**类属性**。
  - **操作方法：** 将对这些元素的操作（如点击、输入），封装成这个类的**实例方法**（例如 `def login(self, user, pass):`）。
- **2. 使用 (Usage)：**
  - 在**测试用例 (Test Case)** 脚本中，我不会再写 `driver.find_element`。
  - 我会**创建页面类的对象**，然后**调用**这个对象的方法来执行业务步骤。
  - 最后，在用例脚本中获取方法的返回值，执行**断言**。
- **好处：** 这样能实现**UI 元素**、**操作逻辑**和**测试用例**的彻底分离。当界面UI变化时，我只需要去修改对应的页面类，而不需要改动测试用例。

**阶段四：框架集成与数据驱动**

在 POM 架构之上，我会引入专业的测试框架（如 **Pytest**）来管理和执行用例。

- **1. 用例管理：** 使用 Pytest 来组织和执行所有的测试用例。
- **2. 数据驱动 (Data-Driven)：**
  - 为了分离“测试数据”和“测试逻辑”，我会使用参数化来进行数据驱动测试。
  - 我会使用 Pytest 的 `@pytest.mark.parametrize` 装饰器。
  - 对于大量的数据（尤其是正反例数据），我会将它们存储在外部文件中，例如 **YAML**、**JSON**、CSV 或 Excel，然后在用例执行时动态读取这些数据。

**阶段五：报告、日志与持续集成 (CI/CD)**

最后，为了让自动化流程闭环，我会完善配套的工程化设施：

- **1. 日志记录 (Logging)：** 在框架中加入详细的日志记录功能，方便在测试失败时快速定位问题。
- **2. 测试报告 (Reporting)：** 集成如 Allure 这样的测试报告库，生成可视化的缺陷报告。
- **3. 持续集成 (CI)：** 将这套自动化脚本对接到公司的 CI/CD 流程中（如 Jenkins），实现自动触发、无人值守的测试。

##### 🚀Appium 和 Pytest 的关系

Appium 和 Pytest 都是“自动化测试框架”，但它们属于完全不同的“层级”。

在面试中，如果面试官问您“你的自动化框架是什么？”，最专业的回答是：“**我搭建了一套基于 Pytest + Appium + POM 模式的自动化测试框架。**”

**Appium** 是我的**底层驱动库**，用它来封装页面操作，解决具体的 UI 交互问题，比如滑动、点击和元素定位。

而 **Pytest** 是我的**测试运行框架**，使用 Pytest 来**组织和管理测试用例**。利用它的 `setup/teardown` 机制来管理驱动的生命周期（确保测试前启动、测试后关闭），利用它的 `assert` 进行断言验证，并结合插件生成可视化的测试报告。

- **Appium** 是 **“执行层” **。
  - 它像是一个**“司机”**。
  - 它只负责干活：控制手机、点击按钮、输入文字、滑动屏幕。
  - 它**不知道**什么是“测试用例”，也不知道什么是“通过”或“失败”。它只管执行命令。
- **Pytest** 是 **“管理层” **。
  - 它像是一个**“考官”**。
  - 它负责指挥：决定先测什么、后测什么（用例调度）。
  - 它负责判断：实际结果和预期结果是否一致（断言 `assert`）。
  - 它负责记录：生成测试报告，告诉您哪些通过了，哪些失败了。

**核心区别对比**

如果不使用 Pytest，仅使用 Appium（像您之前的线性脚本），您的代码是“过程式”的；引入 Pytest 后，您的代码变成了“工程化”的。

| **特性**      | **Appium (驱动者)**             | **Pytest (管理者)**                                 |
| ------------- | ------------------------------- | --------------------------------------------------- |
| **核心作用**  | **操作设备** (点击、滑动、输入) | **管理用例** (发现、执行、断言、报告)               |
| **核心代码**  | `driver.find_element(...)`      | `def test_login(): ... assert ...`                  |
| **如果出错**  | 抛出异常，脚本直接崩溃停止      | 捕获异常，标记该用例为 Fail，**继续执行下一个用例** |
| **测试报告**  | 无 (只能靠 `print` 输出)        | 有 (可生成详细的 HTML 报告，如 Allure)              |
| **前置/后置** | 需手动写代码处理 (很麻烦)       | 自动化处理 (`setup_class`, `teardown_class`)        |

#### 41. json和xml数据交换格式

​	**JSON (JavaScript对象表示法)**：是一种**轻量级**的数据交换格式，使用**键值对** 。更易于人阅读和编写，也更接近C++中的`std::map`或Python中的字典。

​	**XML (可扩展标记语言)**：是一种**标记语言**，使用**带标签的树形结构**。类似于HTML，有开始标签和结束标签，这使得它结构严谨但也**非常冗余**。设计初衷是**传输和存储数据**，但更侧重于**文档的结构化**。

**特点总结：**

- **JSON**：**轻量、快速、易解析**。它更像一个纯粹的“数据包”，非常适合用于性能和效率要求高的API数据交换。
- **XML**：**重量级、功能完备、可扩展性强**。它更像一个“说明文档”，当数据需要复杂的结构描述、元数据（通过属性）或严格的模式验证时，XML更有优势。

！！！**在我的项目中 ，选用JSON是因为它能清晰地描述网络结构 和地址映射 ，并且解析开销小 。**

| **特性**        | **JSON (JavaScript对象表示法)**                              | **XML (可扩展标记语言)**                                     |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心结构**    | **键值对 (Key-Value) 和 数组**                               | **标签树 (Tag Tree)**，有元素、属性和文本                    |
| **冗余性/大小** | **非常简洁，冗余度低**。 （例如：`{"name": "A"}`）           | **相对冗余，更重量级**。 （例如：`<name>A</name>`）。开始和结束标签导致体积更大。 |
| **可读性**      | **对人更友好**，结构清晰，接近编程语言中的对象字面量。       | 对人可读，但标签的嵌套层级多时，可读性会下降。               |
| **数据类型**    | **内置数据类型**： `string`, `number`, `boolean`, `array`, `object`, `null` | **没有内置类型**，所有内容默认都是字符串。需要依赖外部的Schema（如XSD）来定义类型。 |
| **解析难度**    | **非常容易**。 几乎所有语言都有高效的解析器（C++中如`nlohmann/json`），解析速度快，内存占用小。 | **相对复杂**。 解析器需要处理标签、属性、命名空间等，通常有DOM和SAX两种模式，开销更大。 |
| **应用场景**    | **Web API (RESTful API)**，前后端数据交换，现代应用的配置文件。 | 传统企业级应用（如SOAP, WSDL），复杂的配置文件，需要严格模式校验的文档。 |



























### 网络编程核心技术

​	**网络编程最主要的工作就是在发送端把信息通过规定好的协议进行组装包，在接收端按照规定好的协议把包进行解析，从而提取出对应的信息，达到通信的目的。**

**这部分描述非常准确，是网络编程的精髓。** 它清晰地指出了应用层程序员的核心工作：

- **定义应用层协议**: 规定数据的格式、边界和含义。
- **序列化/编码 (组装包)**: 将程序中的数据结构（如 C++ 对象、结构体）转换成可供网络传输的字节流。
- **反序列化/解码 (解析包)**: 将接收到的字节流还原成程序中的数据结构。

#### 1. 什么是套接字（Socket）？socket常见函数和操作？

**核心定义**:
套接字（Socket）是网络编程中用于实现网络通信的**一种抽象**，它代表了网络连接的一个**端点**，提供了在不同主机之间进行通信的接口。通过套接字可以进行数据的发送和接收，通常用于实现客户端和服务器之间的通信。

**常见函数与操作流程**:

1. **服务端流程**:
   - `socket()`: 创建一个套接字。
   - `bind()`: 将套接字与一个IP地址和端口号绑定。
   - `listen()`: 使套接字进入监听状态，等待客户端连接。
   - `accept()`: 阻塞等待，直到一个客户端连接成功，并返回一个新的、代表该连接的套接字。
   - `recv()` & `send()`: 使用新套接字与客户端进行数据收发。
   - `close()`: 关闭套接字。
2. **客户端流程**:
   - `socket()`: 创建一个套接字。
   - `connect()`: 向指定的服务器IP和端口发起连接请求。
   - `write()`/`send()` & `read()`/`recv()`: 与服务器进行数据收发。
   - `close()`: 关闭套接字。

#### 1. 水平触发(LT)和边缘触发(ET)的区别？在ET下，一个socket 已读取200然后不再处理，是不是剩下的300就永远无法读取?

**核心区别**:

- **水平触发 (Level Triggered, LT)**: 只要socket的读/写缓冲区**有数据/可写**，就会**持续**通知你。这是默认模式，更简单易用。
  - **比喻**: 只要水杯里有水，闹钟就一直响。
- **边缘触发 (Edge Triggered, ET)**: 只有当socket的状态**发生变化**时（例如，数据从无到有，或缓冲区从满到可写），才会**通知一次**。
  - **比喻**: 只有在往水杯倒水的那一瞬间，闹钟才响一次。

**关于ET下读取的问题**:
**是的，如果不再有新的数据到达，剩下的300字节将永远不会再触发通知，也就无法被读取了。**

ET模式要求程序员在收到一次通知后，必须**循环地**读取或写入数据，直到返回 `EAGAIN` 或 `EWOULDBLOCK` 错误为止，这表示缓冲区的数据已经处理完毕。如果不这样做，剩余的数据就会被“遗忘”，造成数据丢失。

#### 3. TCP和UDP之间的区别是什么？

- **TCP (传输控制协议)**: **面向连接**、**可靠**的、基于**字节流**的传输层协议。
- **UDP (用户数据报协议)**: **无连接**、**不可靠**的、基于**数据报**的传输层协议。

#### 4. 解释TCP的三次握手和四次挥手过程。

**三次握手 (建立连接)**:

1. **客户端 -> 服务器 (SYN)**: 客户端发送一个SYN包，初始序列号记录为seq=x；请求建立连接。
2. **服务器 -> 客户端 (SYN+ACK)**: 服务器收到后，回复一个SYN+ACK包，序列号记录为seq=y，确认号ack=x+1；表示确认收到了客户端的请求，并同意连接。
3. **客户端 -> 服务器 (ACK)**: 客户端收到后，再发送一个ACK包，序列号记录为seq=x+1，确认号记录为ack=y+1；表示“我也准备好了”，连接建立。

**四次挥手 (断开连接)**:

1. **主动方（如客户端） -> 被动方（如服务器） (FIN)**: 主动方发送FIN包，初始序列号记录为seq=m；表示数据发送完了，准备断开连接。
2. **被动方 -> 主动方 (ACK)**: 被动方回复ACK包，序列号记录为seq=n，确认号ack=m+1；表示确认被动方的FIN，但可能仍有数据未发送完。
3. **被动方 -> 主动方 (FIN)**: 被动方数据也发送完毕后，再发送一个FIN包，序列号记录为seq=k，确认号记录为ack=m+1；表示“我这边也准备关闭了”。
4. **主动方 -> 被动方 (ACK)**: 主动方回复ACK，序列号记录为seq=m+1；确认号ack=k+1；然后进入`TIME_WAIT`状态，等待一段时间后彻底关闭连接。

#### 5. 说说TCP 的粘包和拆包？

**核心原因**: TCP粘包和拆包是在数据传输过程中可能出现的问题，导致接收方无法正确解析和处理数据；根本原因在于TCP是**基于字节流**的传输协议，无法正确地划分出应用层的消息边界。

- **粘包 (Packet Sticking)**: 发送方的多个小数据包，被TCP协议在发送缓冲区中**合并**成一个大数据包发送出去。
- **拆包 (Packet Splitting)**: 发送方的一个大数据包，因为超过了TCP协议单次发送的最大长度（MSS），被**拆分**成多个小数据包发送。

#### 6. 怎么解决拆包和粘包？

**核心思想**: 在应用层**自己定义消息的边界**。

1. **固定长度**: 双方约定每个消息包的长度都是固定的，不足则用特殊字符填充。
2. **特殊分隔符**: 在每个消息包的末尾加上一个特殊的分隔符（如`\r\n`）。
3. **消息头部标识长度**: 在每个消息包前增加一个固定长度的头部，头部中包含整个消息体的长度。这是最通用和推荐的方法。

#### 7. TCP 的主要特点是什么？

1. **面向连接**：通信前必须建立连接。
2. **可靠传输**：通过序列号、确认应答(ACK)、超时重传、数据校验等机制保证数据不丢、不乱、不重复。
3. **面向字节流**：数据没有边界，像水流一样。
4. **全双工通信**：双方可以同时收发数据。
5. **流量控制**：通过滑动窗口机制，防止发送方过快导致接收方来不及处理。
6. **拥塞控制**：当网络拥堵时，主动减慢发送速率。

#### 8. UDP 的主要特点是什么？

1. **无连接**：发送数据前无需建立连接。
2. **尽最大努力交付 (不可靠)**：不保证数据送达、不保证顺序、不保证不重复。
3. **面向报文**：应用层交下来的数据报，添加头部后直接发送，保留消息边界。
4. **开销小，速度快**：头部只有8字节，没有复杂的确认和重传机制。
5. **支持一对一、一对多、多对多**的通信。

#### 9. TCP与UDP有哪些区别？各自的应用场景？

| 特性         | TCP                  | UDP             |
| :----------- | :------------------- | :-------------- |
| **连接性**   | 面向连接             | 无连接          |
| **可靠性**   | 可靠                 | 不可靠          |
| **传输单位** | 字节流               | 数据报          |
| **速度**     | 慢                   | 快              |
| **开销**     | 大（头部20字节+）    | 小（头部8字节） |
| **控制机制** | 有流量控制和拥塞控制 | 无              |

**应用场景**:

- TCP (要求高可靠性):
  - 文件传输 (FTP)
  - 网页浏览 (HTTP/HTTPS)
  - 电子邮件 (SMTP)
- UDP (要求低延迟、可容忍少量丢包):
  - 视频/音频通话 (VoIP)
  - 在线游戏
  - 直播流媒体
  - DNS查询

#### 10. select、poll和epoll之间有什么区别？

这是Linux下I/O多路复用的三种机制，核心区别在于**效率**和**实现方式**。

- **select**:
  - **限制**: 有文件描述符（FD）数量限制（通常是1024）。
  - **拷贝**: 每次调用都需要将FD集合从用户空间**完整拷贝**到内核空间。
  - **遍历**: 内核需要**遍历**所有传入的FD来检查状态，效率随FD数量增加而**线性下降 (O(n))**。
- **poll**:
  - **改进**: 解决了`select`的FD数量限制问题。
  - **缺点**: 仍然存在**完整拷贝**和**线性遍历**的问题，效率本质上没有提升。
- **epoll**:
  - **核心优势**: 效率不随FD数量增加而下降 **(O(1))**。
  - **无须拷贝**: 使用内核和用户空间的共享内存，避免了每次调用的重复拷贝。
  - **无须遍历**: 内核只返回**活跃**的FD列表，而不是让用户自己去遍历查找。
  - **触发模式**: 支持高效的**边缘触发 (ET)** 模式。

**一句话总结**: `select`和`poll`是“轮询”模式，每次都要问内核“谁好了？”；`epoll`是“回调”模式，内核会主动告诉你“这几个好了”。在需要处理大量并发连接的场景下，**epoll是最佳选择**。

#### 11. IP地址分类与网络地址计算

**（1）IP地址分类（传统分类）**

**A类地址**：

- 范围：1.0.0.0 ~ 126.255.255.255
- 第一字节：0xxxxxxx（首位为0）
- 默认子网掩码：255.0.0.0（/8）
- 网络数少，主机数多（2^24-2个），适合大型网络

**B类地址**：

- 范围：128.0.0.0 ~ 191.255.255.255
- 第一字节：10xxxxxx（前两位为10）
- 默认子网掩码：255.255.0.0（/16）
- 中等规模网络（2^16-2个主机）

**C类地址**：

- 范围：192.0.0.0 ~ 223.255.255.255
- 第一字节：110xxxxx（前三位为110）
- 默认子网掩码：255.255.255.0（/24）
- 小型网络（254个主机）

**D类**：224-239开头，组播地址
**E类**：240-255开头，实验保留

**（2）网络地址计算**

**核心方法**：IP地址 **AND** 子网掩码 = 网络地址

**示例**：

- IP：192.168.1.130
- 子网掩码：255.255.255.192（/26）

**计算步骤**：

```
192.168.1.130    → 11000000.10101000.00000001.10000010
255.255.255.192  → 11111111.11111111.11111111.11000000
------------------------------------------------------
网络地址          → 11000000.10101000.00000001.10000000
                 = 192.168.1.128
```

**关键信息**：

- **网络地址**：192.168.1.128（主机位全0）
- **广播地址**：192.168.1.191（主机位全1）
- **可用主机范围**：192.168.1.129 ~ 192.168.1.190
- **主机数**：2^6 - 2 = 62个















### 软件测试理论和方法



#### 第一部分：软件测试理论和方法

这类问题考察你对测试基础知识的掌握程度。



#### 1. 什么是软件测试？它的目的是什么？

**面试官想考察**：你对测试岗位的基本认知和价值观。

**回答思路**：

软件测试是**验证和确认**软件产品是否满足其规定需求或最终用户期望的过程。目的：通过**发现和报告缺陷**来评估软件的质量。

其核心目的并**不仅仅是为了找到Bug**，而是：

1. **质量评估与度量**：提供关于软件质量的客观、量化的数据，帮助项目管理者做出发布决策。
2. **缺陷预防**：尽早地参与到开发流程中（例如，参与需求评审和设计评审），可以预防缺陷的产生。
3. **建立信心**：通过系统的测试，证明软件在特定条件下能够正常工作，为产品的发布建立信心。
4. **风险规避**：识别和评估软件中潜在的风险，并采取措施来降低这些风险带来的负面影响。

**C++加分项**：可以提一下C++的特性，比如内存管理（内存泄漏、野指针）、多线程（数据竞争、死锁）等是测试的重点和难点，需要通过专门的测试手段来保障质量。



#### 2. 请解释一下黑盒测试、白盒测试和灰盒测试，并分别举例说明。

**面试官想考察**：你对核心测试方法的理解和区分能力。

**回答思路**：

这是最经典的问题，一定要回答清晰。

- **黑盒测试**：
  - **定义**：也称为功能测试或行为测试。测试人员不关心程序内部的逻辑结构和实现细节，只关心软件的输入和输出是否符合需求规格。
  - **关注点**：**软件的功能性需求**。
  - **方法举例**：
    - **等价类划分**：将无限的输入数据集合划分为有限的、有代表性的子集（等价类），从每个子集中选取一个测试用例。例如，测试一个接受1-100整数的C++函数，可以划分为三个等价类：有效类（1-100）、无效类（<1）和无效类（>100）。
    - **边界值分析**：等价类划分的补充，重点测试输入域的边界。例如，对上述函数测试0, 1, 2, 99, 100, 101这些边界值。
    - **状态转换测试**：测试系统在不同状态之间转换的正确性。例如，一个TCP连接的状态从`LISTEN` -> `SYN_RCVD` -> `ESTABLISHED`的转换。
    - **因果图/判定表**：适用于输入条件之间有复杂组合关系的场景。
- **白盒测试**：
  - **定义**：也称为结构测试或透明盒测试。测试人员了解程序的内部逻辑结构，并基于代码来设计测试用例，以检查代码中的路径、分支和条件是否都已覆盖。
  - **关注点**：**代码的覆盖率和内部逻辑**。
  - **方法举例 (C++相关)**：
    - **语句覆盖**：确保每行可执行代码至少被执行一次。
    - **判定/分支覆盖**：确保每个判断语句的“真”和“假”分支都至少被执行一次。例如 `if (ptr != nullptr)`，需要测试`ptr`为空和不为空两种情况。
    - **条件覆盖**：确保每个判断语句中每个布尔子条件的“真”和“假”值都至少被执行一次。例如 `if (a > 0 && b < 10)`，需要覆盖 `a>0`, `a<=0`, `b<10`, `b>=10`。
    - **路径覆盖**：覆盖程序中所有可能的执行路径。对于复杂的C++函数，路径数量可能是天文数字，通常只在关键模块中追求高路径覆盖。
- **灰盒测试**：
  - **定义**：介于黑盒和白盒之间。测试人员对程序的内部结构有一定的了解，比如了解其接口、基本架构或数据结构，但不需要关心详细的实现。
  - **应用举例**：接口测试是典型的灰盒测试。你知道API的协议、参数和预期的返回数据结构，可能会通过查看接口文档或部分代码来辅助设计用例，但你并不测试接口内部的完整实现逻辑。



#### 3. 什么是单元测试、集成测试、系统测试和验收测试？它们的关系是什么？

**面试官想考察**：你对V模型或测试金字塔中不同测试阶段的理解。

**回答思路**：

这是测试分层的经典模型，可以从下到上依次介绍：

1. **单元测试 (Unit Testing)**：
   - **层面**：最小的测试单元，通常是函数、方法或类。
   - **执行者**：主要是开发工程师，测试开发工程师也会编写。
   - **目的**：验证代码单元的功能是否正确，是保证代码质量的基础。
   - **C++举例**：为一个C++的`Calculator`类中的`add(int, int)`方法编写测试用例，验证`1+1=2`, `-1+1=0`等。常用的C++单元测试框架有 **GTest (Google Test)**、**Catch2**。
2. **集成测试 (Integration Testing)**：
   - **层面**：将多个经过单元测试的模块组合在一起，测试它们之间的接口和交互是否正确。
   - **执行者**：开发或测试工程师。
   - **目的**：发现与接口、数据交互相关的问题。例如，模块A的输出是否能作为模块B的正确输入。
   - **举例**：测试一个C++后端服务，模块A负责从数据库读取数据，模块B负责将数据序列化为JSON。集成测试就要验证A传给B的数据，B能否正确序列化。
3. **系统测试 (System Testing)**：
   - **层面**：将整个软件系统作为一个整体进行测试，模拟真实的用户环境，验证其是否满足所有功能和非功能性需求（如性能、安全性）。
   - **执行者**：主要是测试工程师。
   - **目的**：验证完整的系统是否满足所有的功能性和非功能性需求（如性能、安全性）。
   - **举例**：测试一个完整的C++开发的服务器应用程序，包括其API、数据库交互、日志系统、配置管理等所有功能。
4. **验收测试 (Acceptance Testing)**：
   - **层面**：通常由最终用户或产品经理来执行，以确认软件是否满足用户的实际需求和期望，是产品发布前的最后一关。
   - **执行者**：通常是最终用户、产品经理或客户。
   - **目的**：确认软件是否满足用户的业务需求和期望。
   - **分类**：Alpha测试（内部验收）和Beta测试（公测）。

**关系**：这四个阶段自下而上，范围逐渐扩大，测试的粒度由细到粗。它们共同构成了**软件测试金字塔**的基础，强调单元测试是基石，应该数量最多、自动化程度最高。



#### 4. 除了功能测试，你还知道哪些非功能性测试？

**面试官想考察**：你的测试知识广度。

**回答思路**：

非功能性测试是衡量系统“工作得好不好”的标准，而不仅仅是“能不能工作”。

- **性能测试**：
  - **负载测试**：测试系统在正常和预期的负载下的表现。
  - **压力测试**：测试系统在超出预期的极限负载下的稳定性和瓶颈。
  - **稳定性/耐力测试**：长时间运行系统，检查是否存在内存泄漏、资源耗尽等问题。
  - **C++相关工具**：可以使用`gprof`、`perf`进行性能剖析，使用`JMeter`、`locust`或自研工具进行压力测试。
- **安全性测试**：检查系统是否存在安全漏洞，如SQL注入、跨站脚本（XSS）、缓冲区溢出等。对于C++，要特别关注内存安全相关的漏洞。
- **兼容性测试**：测试软件在不同的软硬件环境（如不同操作系统、浏览器、CPU架构）下的表现。
- **可靠性测试**：衡量系统在规定时间内持续无故障运行的能力。
- **可用性测试**：从用户体验的角度评估软件是否易于学习、使用和理解。



#### 第二部分：基本的测试流程

这类问题考察你对一个项目从开始到结束，测试是如何参与和工作的。



#### 1. 请描述一下一个完整的软件测试流程。

**面试官想考察**：你对规范化测试过程的理解，体现你的专业性。

**回答思路**：

一个规范的测试流程通常包括以下几个阶段：

1. **需求分析**：理解业务需求和功能规格说明书，进行需求分析，明确要进行功能测试、性能测试、还是安全测试。
2. **测试计划制定**：
   - 明确**测试范围**（测什么，不测什么，要进行集成测试，还是进行整体系统测试）。
   - 制定**测试策略**（用什么方法测试，如自动化为主还是手动为主）。
   - 评估**资源需求**（人力、时间、设备）。
   - 定义**测试环境**。
   - 识别**测试风险**并制定应对计划。
3. **测试用例设计与开发**：
   - 根据需求规格和设计文档，使用等价类、边界值等方法编写**测试用例（Test Case）**。
   - 一个好的测试用例应包含：用例ID、标题、前置条件、测试步骤、预期结果。
   - 组织**用例评审**，确保用例的覆盖率和有效性。
   - 如果是自动化测试，此阶段还包括测试脚本的编写。
4. **测试环境搭建**：准备测试所需的硬件、软件、网络环境，并部署待测版本。
5. **测试执行**：
   - 执行测试用例，记录实际结果。
   - 发现缺陷后，提交详细的**缺陷报告**。
6. **缺陷管理与跟踪**：
   - 使用缺陷管理工具（如Jira、禅道）提交Bug。一个好的Bug报告应包含：标题、复现步骤、实际结果、预期结果、截图/日志、严重等级等。
   - 开发人员修复Bug后，测试人员进行**回归测试**，验证Bug是否被修复，以及修复是否引入了新的问题。
7. **测试报告与总结**：
   - 测试结束后，撰写**测试报告**，总结测试活动，包括执行了多少用例、发现了多少Bug、当前的Bug状态、测试覆盖率、对软件质量的评估以及发布建议。



#### 2. 当你发现一个Bug时，你会怎么做？

**面试官想考察**：你的实际操作能力和沟通协作能力。

**回答思路**：

这是一个流程性很强的问题，要回答得有条理。

1. **确认与复现**：首先，我会尝试稳定地复现这个Bug。我会更换不同的环境或测试数据，以确定Bug出现的具体条件。这一步是为了排除偶发性或环境因素。
2. **定位与分析**：我会尝试缩小问题范围。例如，通过查看日志、使用调试工具（如GDB for C++）、抓包等方式，初步判断问题可能出在前端、后端还是数据库，甚至可能是哪个模块。作为测开，具备初步的定位能力是非常重要的加分项。
3. **提交缺陷报告**：如果确认是Bug，我会到缺陷管理系统（如Jira）上创建一个详细的缺陷报告。报告会遵循**“5C原则”**：
   - **Clear (清晰)**: 描述准确无歧义。
   - **Concise (简洁)**: 只包含必要信息。
   - **Complete (完整)**: 包含复现步骤、环境、版本、日志、截图等所有信息。
   - **Correct (正确)**: 确保所有信息都是准确的。
   - **Consistent (一致)**: 术语和格式保持一致。
4. **沟通与跟踪**：提交报告后，我会将Bug指派给对应的开发负责人，并口头或通过即时通讯工具告知他，确保他已经收到并理解了这个问题。之后，我会持续跟踪Bug的状态，直到它被修复并验证关闭。
5. **总结与反思**：对于一些严重的或典型的Bug，我会思考它为什么会产生，以及是否可以通过流程改进或引入新的测试方法来预防这类Bug的再次出现。



#### 第三部分：测试工具

这类问题考察你的动手能力和技术栈。



#### 1. 你都用过哪些测试工具？分别用在什么场景？

**面试官想考察**：你的工具实践经验。

**回答思路**：

可以分门别类地回答，并突出与C++相关的工具。

- **单元测试框架**：
  - **GTest (Google Test)**：这是C++最主流的单元测试框架。我用它来为C++的类和函数编写单元测试用例，使用它的断言（`ASSERT_EQ`, `EXPECT_TRUE`等）来验证代码逻辑的正确性。它还能很好地与GMock结合，进行Mock测试。
- **缺陷管理工具**：
  - **Jira** / **禅道**：我用它们来提交、跟踪和管理软件缺陷的整个生命周期。
- **版本控制工具**：
  - **Git**：这是代码和测试脚本版本管理的基础。
- **持续集成/持续部署 (CI/CD) 工具**：
  - **Jenkins** / **GitLab CI**：我了解如何配置CI/CD流水线，将自动化测试（特别是单元测试和接口测试）集成进去，实现代码提交后自动触发测试，并生成测试报告。
- **性能测试工具**：
  - **JMeter** / **ab (Apache Benchmark)**：主要用于对后端服务的API进行负载和压力测试。
  - **gprof / perf**：在Linux环境下，我使用这些工具来对C++程序进行性能剖析（Profiling），找出代码中的性能瓶颈，比如CPU占用高的函数。
- **内存分析工具**：
  - **Valgrind**：这是Linux下检查C++内存问题的神器。我用它的`Memcheck`工具来检测内存泄漏、使用未初始化的内存、内存越界读写等问题。
  - **AddressSanitizer (ASan)**：这是Clang/GCC编译器内置的工具，比Valgrind更快，我用它在编译阶段就植入检查代码，能高效地发现内存错误。
- **接口测试工具**：
  - **Postman** / **curl**：用于手动进行HTTP API的测试和调试。



#### 2. 什么是持续集成（CI）？测试在其中扮演什么角色？

**面试官想考察**：你对现代化软件开发流程（DevOps）的理解。

**回答思路**：

**持续集成（Continuous Integration, CI）**是一种软件开发实践，即团队成员频繁地集成他们的工作（通常每人每天至少集成一次），每次集成都通过自动化的构建（包括编译、测试）来验证。

**测试在CI中的角色**是核心和关键：

1. **质量门禁**：自动化测试是CI流水线中的“守门员”。当开发人员提交代码到代码库时，CI服务器（如Jenkins）会自动触发一系列任务：
   - 拉取最新代码。
   - 编译构建。
   - **执行自动化测试**（首先是快速的单元测试，然后是接口测试）。
   - 如果所有测试通过，构建成功，代码才被认为是“好的”，可以合并到主干。如果测试失败，构建失败，立即通知相关开发人员修复。
2. **快速反馈**：CI使得问题能够被极早地发现。代码提交几分钟后就能得到测试结果，开发人员可以在自己的“代码上下文”还没消失时快速修复问题，大大降低了修复成本。
3. **保障主干稳定**：通过在合并前运行测试，CI确保了主代码库（如master或main分支）在任何时候都是可工作的、高质量的。

**总结**：在CI中，测试从一个孤立的、滞后的阶段，转变成了贯穿于整个开发过程的、自动化的、持续的质量保障活动。













### Linux常见命令



**系统与进程监控**

**`ps` **: 查看进程

```
ps
ps -ef	  侧重进程关系（PPID），适合排查依赖进程
ps aux    侧重资源占用（CPU、内存），适合性能调试
```

**`top`**: 查看CPU占用情况



**文件与文本操作**

**`grep` **: 正则表达式匹配（查找字符串）

```
grep [选项] "字符串或正则表达式" 文件名
grep -r "error" ./log
-r 表示递归地在 log 目录及其所有子目录的文件中，查找包含 "error" 字符串的行。这是调试时筛选日志信息的利器。
```

**`find`**: 寻找文件

```
find [搜索路径] [匹配条件] [操作]
find . -name "*.cpp"
在当前目录 `.` 及其子目录下，查找所有以 `.cpp` 结尾的文件。
```

**`less` / `more`**: 查看文件内容。

```
less my_log.log

less 是 more 的增强版，推荐使用。允许你用方向键、PageUp/PageDown 自由地前后翻页查看文件，还可以用 `/` 进行搜索。
```

**`tail`**: 查看文件尾部

```
tail -f app.log
-f (follow) 参数可以实时跟踪 app.log 文件的更新，非常适合实时监控程序运行日志。
```



**磁盘空间管理**

**`df` (Disk Free)**: 查看磁盘分区使用情况

```
df -h
-h (human-readable) 以易于阅读的格式（如GB, MB）显示所有挂载点的磁盘空间使用情况。
```

**`du` (Disk Usage)**: 查看文件或目录的空间占用

```
du -sh .
-s (summarize) 只显示总计，`-h` (human-readable) 以易读格式显示当前目录 `.` 的总大小。
```



**文件与目录管理**

**`pwd` (Print Working Directory)**:显示当前完整目录路径

**`cd` (Change Directory)**: 进入目录

```
cd /path/to/your/project
```

**`tree`**:以树状显示目录结构

```
tree -L 2
`-L 2` 表示只显示到第2层深度，避免在大型项目中输出过多的信息。
```

**`mkdir` (Make Directory)**: 创建文件夹

```
mkdir -p build/output
`-p` (parents) 可以一次性创建多层嵌套的目录，即使父目录不存在。
```

**`touch`**: 创建空文件或更新时间戳

```
`touch main.cpp`
如果文件不存在，则创建一个空文件；如果已存在，则更新其修改时间。
```

**`cp` (Copy)**: 复制文件或目录。

```
cp main.cpp backup/ 或 cp -r src/ build/
复制文件。当复制目录时，必须使用 `-r` (recursive) 参数。
```

**`rm` (Remove)**: 删除文件或目录。

```
`rm main.o` 或 `rm -rf build/`
删除文件。删除目录时，需要 `-r` (recursive)。`-f` (force) 会强制删除不给任何提示，**使用 `rm -rf` 时务必小心**。
```

**`ls` (List)**：列出当前目录下的文件和子目录。

```
ls -alh
这是最常用的组合。`-a` 显示所有文件（包括以 `.` 开头的隐藏文件，如 `.git`），`-l` 显示详细信息（权限、所有者、大小、修改时间），`-h` 使文件大小以易读的格式（如 `KB`, `MB`）显示。
```

**`chmod` (Change Mode)**: 赋权（修改文件权限）

```
chmod 755 my_script.sh
赋予 `my_script.sh` 可执行权限。`755` 是常用权限组合，表示所有者可读/写/执行，同组用户和其他用户可读/执行。
```

**`cat` (Concatenate)**:主要用于一次性**显示**整个文件的内容，或将多个文件**合并**成一个

```
查看单个文件内容
cat my_log.log
将 `my_log.log` 文件的所有内容一次性打印到屏幕上。
如果文件非常大，屏幕会快速滚动，不便于查看。对于大文件，应使用 `less` 或 `more`。
```

```
合并多个文件
cat file1.txt file2.txt > combined.txt
依次读取 `file1.txt` 和 `file2.txt` 的内容，然后将它们合并后的结果通过重定向符 `>` 写入到一个新文件 `combined.txt` 中。
```

```
创建简单文件
cat > new_file.txt
该命令会等待用户从键盘输入内容，输入完成后按 `Ctrl + D` 结束。所有输入的内容都会被保存到 `new_file.txt` 中。
```

```
显示行号
cat -n main.cpp
`-n` 参数会在输出的每一行前面加上行号，非常适合阅读代码或日志文件。
```

**`tar` (Tape Archive)**:将文件打包归档或解压缩。

| 参数 | 作用                              | 示例场景                              |
| ---- | --------------------------------- | ------------------------------------- |
| `-c` | **创建**归档文件                  | `tar -cvf archive.tar file1 dir/`     |
| `-x` | **解压**归档文件                  | `tar -xvf archive.tar`                |
| `-z` | 使用 **gzip** 压缩/解压           | `tar -czvf archive.tar.gz file1`      |
| `-J` | 使用 **xz** 压缩/解压（高压缩率） | `tar -cJvf archive.tar.xz file1`      |
| `-v` | **显示详细过程**（可选）          | 观察正在处理的文件列表                |
| `-f` | **指定归档文件名**（必选）        | 必须紧跟文件名（如 `-f archive.tar`） |
| `-t` | **查看归档内容**                  | `tar -tvf archive.tar`                |
| `-C` | **解压到指定目录**                | `tar -xvf archive.tar -C /path/`      |

```
压缩: tar -czvf my_project.tar.gz ./my_project
解压: tar -xzvf my_project.tar.gz
```

**`wget` (Web Get)**:从网络上下载文件。

```
wget https://github.com/some/library/archive/v1.0.tar.gz
在服务器上直接下载依赖库、数据集或工具，无需图形界面。
```



**其他**

**`echo`**: 在标准输出（屏幕）上打印文本或变量的值。

```
echo "Hello, World!"	(打印字符串)
echo $PATH	(打印环境变量)
echo "Error message" >&2	(输出到标准错误，常用于脚本)
```

**`ln`**:用于创建软链接（ln -s）和硬链接（ln）。

```
ln -s <source_path> <link_path>
sudo ln -s /usr/local/cuda-11.3 /usr/local/cuda 
创建一个软链接类似于 Windows 中的快捷方式，它指向目标文件或目录，而不复制其内容。当程序或脚本尝试访问 `/usr/local/cuda` 时，系统会自动将其重定向到 `/usr/local/cuda-11.3`。
```





### 数据库常用命令



我们将场景设定为：**教务处的老师，正在管理一个名为 `school` 的数据库，里面有一张核心表叫 `student`（学生表）。**

字段假设：`id` (学号), `name` (姓名), `class_name` (班级), `score` (数学成绩)。

以下是针对每个命令的实际应用例子：

#### 一、 搭建与管理 (建档案)

**1. MySQL 创建数据库**

- **场景**：新学期开始了，教务处需要建立一个新的数据库来存储今年的数据。
- **例子**：`CREATE DATABASE school;` （创建一个叫“学校”的数据库）

**2. MySQL 删除数据库**

- **场景**：去年的数据已经归档备份了，旧的数据库不再需要，为了释放服务器空间。
- **例子**：`DROP DATABASE school_2023;` （把“2023年学校库”彻底删掉）

**3. MySQL 选择数据库**

- **场景**：你要开始录入成绩了，得先进入“学校”这个库，防止录错到“食堂数据库”里。
- **例子**：`USE school;`

**4. MySQL 数据类型**

- **场景**：规划学生表的时候，思考每个格子填什么格式。
- **例子**：
  - **学号**是数字，用 `INT`。
  - **姓名**是文字，用 `VARCHAR(10)`。
  - **成绩**可能有小数（95.5），用 `DECIMAL` 或 `FLOAT`。

**5. MySQL 创建数据表**

- **场景**：正式建立“学生表”的架子。

- **例子**：

  ```
  CREATE TABLE student (
      id INT,             -- 学号
      name VARCHAR(20),   -- 姓名
      class_name VARCHAR(10), -- 班级
      score INT           -- 成绩
  );
  ```

**6. MySQL 删除数据表**

- **场景**：这张表建错了（比如少了个字段），或者是一张临时的草稿表，现在想扔掉。
- **例子**：`DROP TABLE student_backup;` （删除备份表）

#### 二、 日常操作 (录入与修改)

**7. MySQL 插入数据**

- **场景**：新来了一个学生叫“李华”，学号101，分在一班，入学摸底考了90分。
- **例子**：`INSERT INTO student VALUES (101, '李华', '一班', 90);`

**8. MySQL 查询数据**

- **场景**：校长想看一眼全校所有学生的花名册。
- **例子**：`SELECT * FROM student;`

**9. MySQL WHERE 子句**

- **场景**：只想查看“一班”的学生名单；或者只想查“不及格（<60分）”的学生。
- **例子**：`SELECT * FROM student WHERE score < 60;`

**10. MySQL UPDATE 更新**

- **场景**：老师发现“李华”的成绩录错了，应该是95分，不是90分。
- **例子**：`UPDATE student SET score = 95 WHERE name = '李华';`

**11. MySQL DELETE 语句**

- **场景**：学生“张三”转学走了，需要把他的档案从表里移除。
- **例子**：`DELETE FROM student WHERE name = '张三';`

**12. MySQL LIKE 子句**

- **场景**：你要找一个学生，只记得他姓“王”，名字忘了。
- **例子**：`SELECT * FROM student WHERE name LIKE '王%';`

**13. MySQL ORDER BY 语句**

- **场景**：期末考试结束了，要按成绩从高到低排个名次。
- **例子**：`SELECT * FROM student ORDER BY score DESC;` （DESC代表降序）

#### 三、 数据统计 (教务分析)

**14. MySQL UNION**

- **场景**：学校有两个社团表，一张是**篮球社**名单，一张是**足球社**名单。你想拉一份“所有参加体育社团的学生名单”（去除重复报名的）。

- **例子**：

  ```
  SELECT name FROM basketball_team
  UNION
  SELECT name FROM soccer_team;
  ```

**15. MySQL 分组 (GROUP BY)**

- **场景**：校长问：“每个班级的数学平均分是多少？” 需要按“班级”把人归堆，然后算平均数。
- **例子**：`SELECT class_name, AVG(score) FROM student GROUP BY class_name;`
  - *结果可能显示：一班 85分，二班 82分...*

**16. MySQL 连接的使用 (JOIN)**

- **场景**：你有两张表。

  - 表A `student`（存了学生名字和**班级ID**）。
  - 表B `class_info`（存了**班级ID**和**班主任名字**）。
  - **需求**：你想查“李华的班主任是谁？”（需要把“学生表”和“班级信息表”连起来看）。

- **例子**：

  ```
  SELECT student.name, class_info.teacher_name
  FROM student
  INNER JOIN class_info ON student.class_id = class_info.id;
  ```

#### 四、改结构（列/字段）和 改数据（行/记录）

这个问题的核心在于区分**“改结构（列/字段）”**和**“改数据（行/记录）”**。这在数据库中是完全不同的两个维度的操作。

我们可以把 `student` 表想象成一个 **Excel 表格**：

- **变动列（字段）**：相当于你要**修改表头**（比如增加一列“电话号码”，或者删掉一列“成绩”）。
- **变动行（数据）**：相当于你要**填写或擦除具体的学生信息**（比如新来了一个学生，或者开除一个学生）。

##### 一、 变动列（字段）—— 修改表的结构

这属于 **DDL (数据定义语言)**，通常使用 `ALTER TABLE` 命令。

**1. 查询表结构（看看有哪些字段）**

- **场景**：你想确认一下现在表里都有哪些列（比如有没有“年龄”这一列？）。

- **命令**：`DESC` (Describe)

- **例子**：

  ```
  DESC student;
  -- 结果会列出：id, name, class_name, score 以及它们的类型
  ```

**2. 添加字段（新增一列）**

- **场景**：教务处要求补充登记学生的“**手机号**”。

- **命令**：`ALTER TABLE ... ADD`

- **例子**：

  ```
  ALTER TABLE student ADD phone VARCHAR(11);
  -- 执行后，表里多了一列 phone，所有学生的这一列暂时都是空的 (NULL)
  ```

**3. 删除字段（剪掉一列）**

- **场景**：教务处觉得“**手机号**”涉及隐私，不准存了，要把这一列彻底删掉。

- **命令**：`ALTER TABLE ... DROP`

- **例子**：

  ```
  ALTER TABLE student DROP COLUMN phone;
  -- 执行后，phone 这一列彻底消失，里面存的所有号码也没了
  ```

##### 二、 变动行（学生信息）—— 修改表的数据

这属于 **DML (数据操作语言)**，是我们最日常的操作。

**1. 查询学生信息（查找某一行）**

- **场景**：你想查一下**学号是 101** 的那个学生的所有信息。

- **命令**：`SELECT`

- **例子**：

  ```
  SELECT * FROM student WHERE id = 101;
  ```

**2. 添加学生信息（新增一行）**

- **场景**：新转来一个学生叫**赵六**，学号105，二班，考了88分。

- **命令**：`INSERT INTO`

- **例子**：

  ```
  INSERT INTO student (id, name, class_name, score) 
  VALUES (105, '赵六', '二班', 88);
  ```

**3. 删除学生信息（删掉一行）**

- **场景**：**赵六**退学了，要把他的那一行记录删掉。

- **命令**：`DELETE`

- **例子**：

  ```
  DELETE FROM student WHERE id = 105;
  -- 警告：一定要加 WHERE，否则会把全校学生都删光！
  ```



#### **MySQL 常用命令速查表**

| **功能分类**           | **操作描述**              | **命令 / SQL 语句**                                          |
| ---------------------- | ------------------------- | ------------------------------------------------------------ |
| **连接与退出**         | 连接到 MySQL 数据库       | `mysql -u 用户名 -p`                                         |
|                        | 查看当前用户              | `SELECT USER();`                                             |
|                        | 退出 MySQL                | `EXIT;`                                                      |
| **数据库操作**         | 查看所有数据库            | `SHOW DATABASES;`                                            |
|                        | 选择/使用一个数据库       | `USE 数据库名;`                                              |
|                        | 创建一个新数据库          | `CREATE DATABASE 数据库名;`                                  |
|                        | 删除一个数据库            | `DROP DATABASE 数据库名;`                                    |
| **表结构操作 (基础)**  | 查看当前库所有表          | `SHOW TABLES;`                                               |
|                        | 创建一个新表              | `CREATE TABLE 表名 (列名1 数据类型 [约束], 列名2 数据类型 [约束], ...);` |
|                        | 删除一个表                | `DROP TABLE 表名;`                                           |
|                        | 查看表结构                | `DESCRIBE 表名;`   `DESC 表名;`   `SHOW COLUMNS FROM 表名;`   `EXPLAIN 表名;` |
|                        | 查看表的创建 SQL (含约束) | `SHOW CREATE TABLE 表名;`                                    |
|                        | 查看表的统计信息          | `SHOW TABLE STATUS LIKE '表名';`                             |
| **表结构修改 (ALTER)** | 添加列                    | `ALTER TABLE 表名 ADD 列名 数据类型 [约束];`                 |
|                        | 删除列                    | `ALTER TABLE 表名 DROP 列名;`                                |
|                        | 修改列类型/属性           | `ALTER TABLE 表名 MODIFY 列名 数据类型 [约束];`              |
|                        | 重命名列                  | `ALTER TABLE 表名 CHANGE 旧列名 新列名 数据类型 [约束];`     |
| **数据操作 (CRUD)**    | 插入数据                  | `INSERT INTO 表名 (列1, 列2, ...) VALUES (值1, 值2, ...);`   |
|                        | 查询所有数据              | `SELECT * FROM 表名;`                                        |
|                        | 条件查询数据              | `SELECT 列1, 列2, ... FROM 表名 WHERE 条件;`                 |
|                        | 更新数据                  | `UPDATE 表名 SET 列1 = 值1, 列2 = 值2, ... WHERE 条件;`      |
|                        | 删除数据                  | `DELETE FROM 表名 WHERE 条件;`                               |
| **索引与约束**         | 查看表的索引              | `SHOW INDEX FROM 表名;`                                      |
|                        | 创建索引                  | `CREATE INDEX 索引名 ON 表名 (列名);`                        |
|                        | 删除索引                  | `DROP INDEX 索引名 ON 表名;`                                 |
|                        | 查看表的约束              | `SHOW CREATE TABLE 表名;` (约束信息包含在创建表的 SQL 中)    |
| **用户与权限**         | 创建用户                  | `CREATE USER '用户名'@'主机' IDENTIFIED BY '密码';`          |
|                        | 授权用户                  | `GRANT 权限 ON 数据库名.* TO '用户名'@'主机';`               |
|                        | 刷新权限                  | `FLUSH PRIVILEGES;`                                          |
